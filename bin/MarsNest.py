#!/usr/bin/env python
"""
The MarsNest executable does not accept any input.

The executable requires the presence of grid_spec files in the current directory.
Test grid_spec files can be generated by running the AmesGCM with 0 days as the input.


Third-party Requirements:

    * ``numpy``
    * ``argparse``
    * ``netCDF4``
    * ``matplotlib``
    * ``os``
"""
#============Import modules==============

# Make print statements appear in color
from amescap.Script_utils import (
    Yellow, Nclr, Green, Red
)

import numpy as np #numerics module
import matplotlib.pyplot as plt #graphical libraries
from netCDF4 import Dataset
import argparse   # parse arguments
import os

from matplotlib.ticker import MultipleLocator  #adjust tic spacing on graphs
from matplotlib.backends.backend_pdf import PdfPages
import matplotlib.path as mpltPath

#Might be needed on PFE if issues with thr Qt back-end
import matplotlib
matplotlib.use('Agg')

def debug_wrapper(func):
    """
    A decorator that wraps a function with error handling
    based on the --debug flag.
    
    If the --debug flag is set, it prints the full traceback
    of any exception that occurs. Otherwise, it prints a
    simplified error message.

    :param func: The function to wrap.
    :type   func: function
    :return: The wrapped function.
    :rtype:  function
    :raises Exception: If an error occurs during the function call.
    :raises TypeError: If the function is not callable.
    :raises ValueError: If the function is not found.
    :raises NameError: If the function is not defined.
    :raises AttributeError: If the function does not have the
        specified attribute.
    :raises ImportError: If the function cannot be imported.
    :raises RuntimeError: If the function cannot be run.
    :raises KeyError: If the function does not have the
        specified key.
    :raises IndexError: If the function does not have the
        specified index.
    :raises IOError: If the function cannot be opened.
    :raises OSError: If the function cannot be accessed.
    :raises EOFError: If the function cannot be read.
    :raises MemoryError: If the function cannot be allocated.
    :raises OverflowError: If the function cannot be overflowed.
    :raises ZeroDivisionError: If the function cannot be divided by zero.
    :raises StopIteration: If the function cannot be stopped.
    :raises KeyboardInterrupt: If the function cannot be interrupted.
    :raises SystemExit: If the function cannot be exited.
    :raises AssertionError: If the function cannot be asserted.
    """

    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        global debug
        try:
            return func(*args, **kwargs)
        except Exception as e:
            if debug:
                # In debug mode, show the full traceback
                print(f"{Red}ERROR in {func.__name__}: {str(e)}{Nclr}")
                traceback.print_exc()
            else:
                # In normal mode, show a clean error message
                print(f"{Red}ERROR in {func.__name__}: {str(e)}\nUse "
                      f"--debug for more information.{Nclr}")
            return 1  # Error exit code
    return wrapper

# ======================================================================
#                           ARGUMENT PARSER
# ======================================================================

parser = argparse.ArgumentParser(
    prog=('MarsNest'),
    description=(
        f"{Yellow}Creates a global map of Mars from grid_spec files\n"
        f"including any nests. This tool can be used to orient nest\n"
        f"positions. The executable requires the presence of grid_spec\n"
        f"files in the current directory. Test grid_spec files can be\n"
        f"generated by running the AmesGCM with 0 days as the input.\n"
        f"{Nclr}\n\n"
    ),
    formatter_class=argparse.RawTextHelpFormatter
)

# Arguments: Only debug

parser.add_argument('--debug', action='store_true',
    help=(
        f"Use with any other argument to pass all Python errors and\n"
        f"status messages to the screen when running CAP.\n"
        f"{Green}Example:\n"
        f"> MarsNest --debug"
        f"{Nclr}\n\n"
    )
 )

args = parser.parse_args()
debug = args.debug


# ======================================================================
#                               DEFINITIONS
# ======================================================================


def extract_grid(lon,lat,varIN,lon_target,lat_target,window_lon,window_lat):
    '''
    This function extract a subsample of a larger grid variable. It deals with wrapping around the longitudes on the edges of the grid.
    Args:
        lon: 1D array of longitude -180/+180
        lat: 1D array of latitudes -90/+90
        varIN: 2D array  var2IN(lat,lon)
        lon_target: float, center longitude of subgrid (e.g =-136.)
        lat_target: float, center latitude of subgrid  (e.g =40.)
        window_lon: width of window in degree   (e.g =10.)
        window_lat: heigth of window in degree  (e.g. =5.)
    Returns:
        lon_window: 1D array of truncated longitude (may not be increasing)
        lat_window: 1D array of truncated latitudes (may not be increasing)
        varIN_out:  2D array of subsample of varIN
    '''
    nlat=len(lat)
    nlon=len(lon)
    Dangle=lon[1]-lon[0] #angle increment
    wlon=int(0.5*window_lon/Dangle)# degree window, half side
    wlat=int(0.5*window_lat/Dangle)# degree window, hal f side

    #print("(wlat,wlon)= (%i,%i)"%(2*wlat+1,2*wlon+1))

    ilat_c=int((lat_target-lat[0])/Dangle)    #lat index of center of requested tile
    ilon_c=int((lon_target-lon[0])/Dangle)   #lon index of center of requested tile

    #case where the request is close to the south pole (no issue at the north pole)
    # For example --> if lat() has 15 elements, lat[-5:15] will raise an error but lat[0:37] will just return lat[0:15]
    if lat_target-window_lat/2<lat[0]:ilat_c=wlat

    lat_window=lat[ilat_c-wlat:ilat_c+wlat+1] #latitude array

    if lon_target-window_lon/2<lon[0]:
        window_left=int((lon[0]-(lon_target-window_lon/2.))/Dangle) #number of points outside left of grid
        topo_l=varIN[ilat_c-wlat:ilat_c+wlat+1,nlon-window_left:nlon] #left
        topo_r=varIN[ilat_c-wlat:ilat_c+wlat+1,0:2*wlon-window_left+1] #right
        varIN_out=np.hstack((topo_l,topo_r)) #combine left and right to wrap around
        lon_window=np.append(lon[nlon-window_left:nlon],lon[0:2*wlon-window_left+1])

    elif lon_target+window_lon/2>lon[-1]:
        window_right=int(((lon_target+window_lon/2.)-lon[-1])/Dangle) #number of points outside left of grid
        topo_l=varIN[ilat_c-wlat:ilat_c+wlat+1,nlon-(2*wlon-window_right):nlon] #left
        topo_r=varIN[ilat_c-wlat:ilat_c+wlat+1,0:window_right+1] #right
        varIN_out=np.hstack((topo_l,topo_r)) #combine left and right to wrap around
        lon_window=np.append(lon[nlon-(2*wlon-window_right):nlon],lon[0:window_right+1])

    else:
    #---------rest of points------------------
        varIN_out=varIN[ilat_c-wlat:ilat_c+wlat+1,ilon_c-wlon:ilon_c+wlon+1]
        lon_window=lon[ilon_c-wlon:ilon_c+wlon+1]

    return lon_window,lat_window,varIN_out

def extract_path_basename(filename):
    '''
    Return the path and basename of a file. If only the filename is provided, assume it is the current directory
    Args:
        filename: e.g. 'XXXXX.fixed.nc', './history/XXXXX.fixed.nc' or '/home/user/history/XXXXX.fixed.nc'
    Returns:
        filepath : '/home/user/history/XXXXX.fixed.nc' in all the cases above
        basename:   XXXXX.fixed.nc in all the cases above

    ***NOTE***
    This routine does not check for file existence and only operates on the provided input string.
    '''
    #Get the filename without the path
    if '/' in filename or '\\' in filename :
        filepath,basename=os.path.split(filename)
    else:
        filepath=os.getcwd()
        basename=    filename

    # Is the home ('~') symbol is included, expend the user path
    if '~' in filepath:filepath=  os.path.expanduser(filepath)
    return filepath,basename

def list_full_paths(input_path):
    '''
    List all files in directory.
    '''
    return [os.path.join(input_path, file) for file in os.listdir(input_path)]



def find_tile_number(filename):
    '''
    Return the line number given a file name.
    (Spit grid_spec.nest03.tile8.nc as  "grid_spec.nest03" ".tile" "8.nc" and remove ".nc"
    '''
    return filename.split('.tile')[1][:-3]



def get_poly_path(gridspec_filename):
    '''
    Return the North West and South East corner of a gridscspec file.
    Args:
        gridspec_filename: full path to a gridscpec file
    Return:
        poly = a numpy array size (N,(lat,lon) )with the corners
    '''
    f=Dataset(gridspec_filename, 'r', format='NETCDF4')

    #Extract 4 corners. Tiles may be rotated to North West is not necessarily at (0,0)
    C1=np.asarray([f.variables['grid_lat'][0,0],f.variables['grid_lon'][0,0]])
    C2=np.asarray([f.variables['grid_lat'][0,-1],f.variables['grid_lon'][0,-1]])
    C3=np.asarray([f.variables['grid_lat'][-1,-1],f.variables['grid_lon'][-1,-1]])
    C4=np.asarray([f.variables['grid_lat'][-1,0],f.variables['grid_lon'][-1,0]])
    f.close()
    lats=np.array([C1[0],C2[0],C3[0],C4[0]])
    lons=np.array([C1[1],C2[1],C3[1],C4[1]])
    #X,Y couples
    return np.array([[C1[1],C1[0]],[C2[1],C2[0]],[C3[1],C3[0]],[C4[1],C4[0]]])

def get_corners(poly_path):
    '''
    Return the North West and South East corner of a gridscspec file.
    Args:
        gridspec_filename: full path to a gridscpec file
    Return:
        NWc,SEc =(lat,lon) of the two corners
    '''

    lons=poly_path[:,0]
    lats=poly_path[:,1]


    #Calculate angular distance between the NW and SE corners
    dist_NW=np.abs(lats-lats.max())**2+np.abs(lons-lons.min())
    dist_SE=np.abs(lats-lats.min())**2+np.abs(lons-lons.max())

    #The corners that shows the min distances are the NW and SE corners
    ii_NW=np.argmin(dist_NW)
    ii_SE=np.argmin(dist_SE)

    NWc=np.array([lats[ii_NW],lons[ii_NW]])
    SEc=np.array([lats[ii_SE],lons[ii_SE]])
    return NWc,SEc

def is_child(poly_path_child,poly_path_parent):
    '''
    Test if a grid is nested in another grid.
    Args:
        poly_path_child: a polygon object wit the 4 corners of the child tile
        poly_path_parent: a polygon object wit the 4 corners of the parent tile
    Returns:
        bool: True if all the corners of the child grids are contained within the path defined by the paretn grid

    '''
    path = mpltPath.Path(poly_path_parent)
    inside = path.contains_points(poly_path_child)
    return  inside.all()


nskip=2 #skip a couple points in the topography file to speed-up plotting
thick_line=0.5 #line thickness for individual cells

#TODO development  map_dir='/Users/akling/Data/Mars_topo/mars_topo_mola_16.nc'
map_dir='/nobackup/rurata/FMS_MARS_data/mars_topo.nc'

f=Dataset(map_dir,'r')
lon=f.variables['lon'][::nskip]
lat=f.variables['lat'][::nskip]
topo=f.variables['topo'][::nskip,::nskip]
f.close()


#===List of tiles to includes====

# ======================================================
#                  ARGUMENT PARSER
# ======================================================
parser = argparse.ArgumentParser(description="""\033[93m Nested grid utility, V%s\033[00m """,
                                 formatter_class=argparse.RawTextHelpFormatter)

parser.add_argument('input_path', nargs='?', default=os.getcwd(),
                    help='Optional path to /history directory \n'
                    '> Usage: MarsNest.py path_to_history/')


def main():
    input_path=parser.parse_args().input_path
    if input_path=='.':input_path=os.getcwd() #Special case where current dir ('.') is provided
    list_dir = list_full_paths(input_path) #Files in directory
    avail_grid_specs = [k for k in list_dir if 'grid_spec' in k]

    #List of nest only, note that the directory, e.g. C24_nest/history may contain 'nest' so the test is done on the basename, not the fullpath
    avail_grid_nest=[]
    for name_tmp in avail_grid_specs:
        _,basename = extract_path_basename(name_tmp) #Extract path and basename at two objects
        if 'nest' in basename:avail_grid_nest.append(name_tmp)

    outfile=input_path+'/nest_layout.pdf'

    plt.close('all')
    with PdfPages(outfile) as pdf:
        #Mother grid
        plt.figure(figsize=(12,10))
        ax=plt.subplot(111)
        plt.contourf(lon,lat,topo,32,cmap='jet')
        for name in avail_grid_specs:

            f=Dataset(name, 'r', format='NETCDF4')
            grid_lon=f.variables['grid_lon'][:]
            grid_lat=f.variables['grid_lat'][:]
            f.close()
            tileN=find_tile_number(name)
            #Get NWc corner
            poly=get_poly_path(name)
            NWc,_= get_corners(poly)

            x, y = grid_lon,grid_lat
            #Filter projection singularities
            x[x>0.9*1e+30]=np.NaN
            y[y>0.9*1e+30]=np.NaN
            _,basename = extract_path_basename(name) #Extract path and basename at two objects
            #Plot the grid only for the mother
            if 'nest' not in basename:
                for i in range(0,grid_lon.shape[0]):
                    plt.plot(x[:,i],   y[:,i], '-k',lw= thick_line) #vertical
                    plt.plot(x[i,:],   y[i,:], '-k',lw= thick_line) #horizontal
                #Add tile number
                latNWc,lonNWc=NWc
                plt.text(lonNWc+4,latNWc-4,tileN,fontsize='18',color='r')

            plt.plot(x[0,:],  y[0,:],  'r',lw=3 )#S
            plt.plot(x[:,-1], y[:,-1], 'r',lw=3 )#E
            plt.plot(x[-1,:], y[-1,:], 'r',lw=3 )#N
            plt.plot(x[:,0],   y[:,0], 'r',lw=3 )#W

        ax.xaxis.set_major_locator(MultipleLocator(30))
        ax.xaxis.set_minor_locator(MultipleLocator(10))
        ax.yaxis.set_major_locator(MultipleLocator(30))
        ax.yaxis.set_minor_locator(MultipleLocator(10))
        ax.set_xlim([0,360])
        ax.set_ylim([-90,90])
        pdf.savefig()  # saves the current figure into a pdf page
        plt.close()


        #====Add one page for each nest=====
        for name in avail_grid_nest:
            _,basename = extract_path_basename(name) #Extract path and basename at two objects
            plt.figure(figsize=(12,10))
            ax=plt.subplot(111)
            f=Dataset(name, 'r', format='NETCDF4')
            grid_lon=f.variables['grid_lon'][:]
            grid_lat=f.variables['grid_lat'][:]
            f.close()

            #Get grid center lat/lon and angular width of the tile
            N_tile=grid_lon.shape[0]
            lon_cent=grid_lon[N_tile//2,N_tile//2]
            lat_cent=grid_lat[N_tile//2,N_tile//2]
            Dlon=(grid_lon.max()-grid_lon.min())

            #Get high res topo
            lon_tmp,lat_tmp,topo_tmp=extract_grid(lon=lon,lat=lat,varIN=topo,lon_target=lon_cent,lat_target=lat_cent,window_lon=Dlon,window_lat=Dlon)


            poly_parent=get_poly_path(name)
            NWc,_= get_corners(poly_parent)
            x, y = grid_lon,grid_lat
            #Filter projection singularities
            x[x>0.9*1e+30]=np.NaN
            y[y>0.9*1e+30]=np.NaN

            tileN=find_tile_number(name)

            plt.contourf(lon_tmp,lat_tmp,topo_tmp,32,cmap='jet')
            plt.plot(x[0,:],  y[0,:],  'r',lw=3 )#S
            plt.plot(x[:,-1], y[:,-1], 'r',lw=3 )#E
            plt.plot(x[-1,:], y[-1,:], 'r',lw=3 )#N
            plt.plot(x[:,0],   y[:,0], 'r',lw=3 )#W

            #Add tile number
            latNWc,lonNWc=NWc
            plt.text(lonNWc+0.5,latNWc-0.5,tileN,fontsize='18',color='r')
            #Plot the nested nest
            for name2 in avail_grid_nest:
                poly_child=get_poly_path(name2)
                if name2!=name and is_child(poly_child,poly_parent):
                    f=Dataset(name2, 'r', format='NETCDF4')
                    grid_lon=f.variables['grid_lon'][:]
                    grid_lat=f.variables['grid_lat'][:]
                    f.close()
                    x, y = grid_lon,grid_lat
                    #Filter projection singularities
                    x[x>0.9*1e+30]=np.NaN
                    y[y>0.9*1e+30]=np.NaN
                    plt.plot(x[0,:],  y[0,:],  'r',lw=3 )#S
                    plt.plot(x[:,-1], y[:,-1], 'r',lw=3 )#E
                    plt.plot(x[-1,:], y[-1,:], 'r',lw=3 )#N
                    plt.plot(x[:,0],   y[:,0], 'r',lw=3 )#W

            pdf.savefig()  # saves the current figure into a pdf page
            plt.close()


    print(outfile +' was created')

if __name__ == '__main__':
    main()
