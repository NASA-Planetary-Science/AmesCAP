<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>amescap.FV3_utils &mdash; AmesCAP 1.0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=f2a433a1"></script>
        <script src="../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            AmesCAP
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../MarsPull/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">MarsPull</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../MarsFormat/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">MarsFormat</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../MarsFiles/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">MarsFiles</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../MarsVars/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">MarsVars</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../MarsInterp/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">MarsInterp</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../MarsPlot/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">MarsPlot</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">Examples &amp; Use Cases</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">AmesCAP</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active"><code class="xref py py-mod docutils literal notranslate"><span class="pre">amescap.FV3_utils</span></code></li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../_sources/autoapi/amescap/FV3_utils/index.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-amescap.FV3_utils">
<span id="amescap-fv3-utils"></span><h1><a class="reference internal" href="#module-amescap.FV3_utils" title="amescap.FV3_utils"><code class="xref py py-mod docutils literal notranslate"><span class="pre">amescap.FV3_utils</span></code></a><a class="headerlink" href="#module-amescap.FV3_utils" title="Link to this heading"></a></h1>
<p>FV3_utils contains internal Functions for processing data in MGCM output
files such as vertical interpolation.
These functions can be used on their own outside of CAP if they are
imported as a module:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="o">/</span><span class="n">u</span><span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">FV3_utils</span> <span class="kn">import</span> <span class="nn">fms_press_calc</span>
</pre></div>
</div>
<dl class="simple">
<dt>Third-party Requirements:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">numpy</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">warnings</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">scipy</span></code></p></li>
</ul>
</dd>
</dl>
<section id="module-contents">
<h2>Module Contents<a class="headerlink" href="#module-contents" title="Link to this heading"></a></h2>
<section id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Link to this heading"></a></h3>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#amescap.FV3_utils.fms_press_calc" title="amescap.FV3_utils.fms_press_calc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fms_press_calc</span></code></a>(psfc, ak, bk[, lev_type])</p></td>
<td><p>Returns the 3D pressure field from the surface pressure and the</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#amescap.FV3_utils.fms_Z_calc" title="amescap.FV3_utils.fms_Z_calc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fms_Z_calc</span></code></a>(psfc, ak, bk, T[, topo, lev_type])</p></td>
<td><p>Returns the 3D altitude field [m] AGL (or above aeroid).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#amescap.FV3_utils.find_n0" title="amescap.FV3_utils.find_n0"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_n0</span></code></a>(Lfull_IN, Llev_OUT[, reverse_input])</p></td>
<td><p>Return the index for the level(s) just below <code class="docutils literal notranslate"><span class="pre">Llev_OUT</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#amescap.FV3_utils.find_n" title="amescap.FV3_utils.find_n"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_n</span></code></a>(X_IN, X_OUT[, reverse_input, modulo])</p></td>
<td><p>Maps the closest index from a 1D input array to a ND output array</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#amescap.FV3_utils.expand_index" title="amescap.FV3_utils.expand_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">expand_index</span></code></a>(Nindex, VAR_shape_axis_FIRST, axis_list)</p></td>
<td><p>Repeat interpolation indices along an axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#amescap.FV3_utils.vinterp" title="amescap.FV3_utils.vinterp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vinterp</span></code></a>(varIN, Lfull, Llev[, type_int, reverse_input, ...])</p></td>
<td><p>Vertical linear or logarithmic interpolation for pressure or</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#amescap.FV3_utils.axis_interp" title="amescap.FV3_utils.axis_interp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">axis_interp</span></code></a>(var_IN, x, xi, axis[, reverse_input, ...])</p></td>
<td><p>One dimensional linear/logarithmic interpolation along one axis.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#amescap.FV3_utils.layers_mid_point_to_boundary" title="amescap.FV3_utils.layers_mid_point_to_boundary"><code class="xref py py-obj docutils literal notranslate"><span class="pre">layers_mid_point_to_boundary</span></code></a>(pfull, sfc_val)</p></td>
<td><p>A general description for the layer boundaries is:</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#amescap.FV3_utils.polar2XYZ" title="amescap.FV3_utils.polar2XYZ"><code class="xref py py-obj docutils literal notranslate"><span class="pre">polar2XYZ</span></code></a>(lon, lat, alt[, Re])</p></td>
<td><p>Spherical to cartesian coordinate transformation</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#amescap.FV3_utils.interp_KDTree" title="amescap.FV3_utils.interp_KDTree"><code class="xref py py-obj docutils literal notranslate"><span class="pre">interp_KDTree</span></code></a>(var_IN, lat_IN, lon_IN, lat_OUT, lon_OUT)</p></td>
<td><p>Inverse distance-weighted interpolation using nearest neighboor for</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#amescap.FV3_utils.cart_to_azimut_TR" title="amescap.FV3_utils.cart_to_azimut_TR"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cart_to_azimut_TR</span></code></a>(u, v[, mode])</p></td>
<td><p>Convert cartesian coordinates or wind vectors to radians using</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#amescap.FV3_utils.sfc_area_deg" title="amescap.FV3_utils.sfc_area_deg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sfc_area_deg</span></code></a>(lon1, lon2, lat1, lat2[, R])</p></td>
<td><p>Return the surface between two sets of latitudes/longitudes:</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#amescap.FV3_utils.area_meridional_cells_deg" title="amescap.FV3_utils.area_meridional_cells_deg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">area_meridional_cells_deg</span></code></a>(lat_c, dlon, dlat[, ...])</p></td>
<td><p>Return area of invidual cells for a meridional band of thickness</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#amescap.FV3_utils.area_weights_deg" title="amescap.FV3_utils.area_weights_deg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">area_weights_deg</span></code></a>(var_shape, lat_c[, axis])</p></td>
<td><p>Return weights for averaging the variable.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#amescap.FV3_utils.areo_avg" title="amescap.FV3_utils.areo_avg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">areo_avg</span></code></a>(VAR, areo, Ls_target, Ls_angle[, symmetric])</p></td>
<td><p>Return a value average over a central solar longitude</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#amescap.FV3_utils.mass_stream" title="amescap.FV3_utils.mass_stream"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mass_stream</span></code></a>(v_avg, lat, level[, type, psfc, H, factor])</p></td>
<td><p>Compute the mass stream function:</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#amescap.FV3_utils.vw_from_MSF" title="amescap.FV3_utils.vw_from_MSF"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vw_from_MSF</span></code></a>(msf, lat, lev[, ztype, norm, psfc, H])</p></td>
<td><p>Return the V and W components of the circulation from the mass</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#amescap.FV3_utils.alt_KM" title="amescap.FV3_utils.alt_KM"><code class="xref py py-obj docutils literal notranslate"><span class="pre">alt_KM</span></code></a>(press[, scale_height_KM, reference_press])</p></td>
<td><p>Gives the approximate altitude [km] for a given pressure</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#amescap.FV3_utils.press_pa" title="amescap.FV3_utils.press_pa"><code class="xref py py-obj docutils literal notranslate"><span class="pre">press_pa</span></code></a>(alt_KM[, scale_height_KM, reference_press])</p></td>
<td><p>Gives the approximate altitude [km] for a given pressure</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#amescap.FV3_utils.shiftgrid_360_to_180" title="amescap.FV3_utils.shiftgrid_360_to_180"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shiftgrid_360_to_180</span></code></a>(lon, data)</p></td>
<td><p>This function shifts ND data from a 0-360 to a -180/180 grid.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#amescap.FV3_utils.shiftgrid_180_to_360" title="amescap.FV3_utils.shiftgrid_180_to_360"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shiftgrid_180_to_360</span></code></a>(lon, data)</p></td>
<td><p>This function shifts ND data from a -180/180 to a 0-360 grid.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#amescap.FV3_utils.second_hhmmss" title="amescap.FV3_utils.second_hhmmss"><code class="xref py py-obj docutils literal notranslate"><span class="pre">second_hhmmss</span></code></a>(seconds[, lon_180])</p></td>
<td><p>Given the time [sec], return local true solar time at a</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#amescap.FV3_utils.sol_hhmmss" title="amescap.FV3_utils.sol_hhmmss"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sol_hhmmss</span></code></a>(time_sol[, lon_180])</p></td>
<td><p>Given the time in days, return return local true solar time at a</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#amescap.FV3_utils.UT_LTtxt" title="amescap.FV3_utils.UT_LTtxt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">UT_LTtxt</span></code></a>(UT_sol[, lon_180, roundmin])</p></td>
<td><p>Returns the time in HH:MM:SS at a certain longitude.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#amescap.FV3_utils.dvar_dh" title="amescap.FV3_utils.dvar_dh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dvar_dh</span></code></a>(arr[, h])</p></td>
<td><p>Differentiate an array <code class="docutils literal notranslate"><span class="pre">A[dim1,</span> <span class="pre">dim2,</span> <span class="pre">dim3...]</span></code> w.r.t <code class="docutils literal notranslate"><span class="pre">h</span></code>. The</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#amescap.FV3_utils.zonal_detrend" title="amescap.FV3_utils.zonal_detrend"><code class="xref py py-obj docutils literal notranslate"><span class="pre">zonal_detrend</span></code></a>(VAR)</p></td>
<td><p>Substract the zonal average mean value from a field.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#amescap.FV3_utils.get_trend_2D" title="amescap.FV3_utils.get_trend_2D"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_trend_2D</span></code></a>(VAR, LON, LAT[, type_trend])</p></td>
<td><p>Extract spatial trends from the data. The output can be directly</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#amescap.FV3_utils.regression_2D" title="amescap.FV3_utils.regression_2D"><code class="xref py py-obj docutils literal notranslate"><span class="pre">regression_2D</span></code></a>(X, Y, VAR[, order])</p></td>
<td><p>Linear and quadratic regression on the plane.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#amescap.FV3_utils.daily_to_average" title="amescap.FV3_utils.daily_to_average"><code class="xref py py-obj docutils literal notranslate"><span class="pre">daily_to_average</span></code></a>(varIN, dt_in[, nday, trim])</p></td>
<td><p>Bin a variable from an <code class="docutils literal notranslate"><span class="pre">atmos_daily</span></code> file format to the</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#amescap.FV3_utils.daily_to_diurn" title="amescap.FV3_utils.daily_to_diurn"><code class="xref py py-obj docutils literal notranslate"><span class="pre">daily_to_diurn</span></code></a>(varIN, time_in)</p></td>
<td><p>Bin a variable from an <code class="docutils literal notranslate"><span class="pre">atmos_daily</span></code> file into the</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#amescap.FV3_utils.gauss_profile" title="amescap.FV3_utils.gauss_profile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gauss_profile</span></code></a>(x, alpha[, x0])</p></td>
<td><p>Return Gaussian line shape at x. This can be used to generate a</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#amescap.FV3_utils.compute_uneven_sigma" title="amescap.FV3_utils.compute_uneven_sigma"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_uneven_sigma</span></code></a>(num_levels, N_scale_heights, ...)</p></td>
<td><p>Construct an initial array of sigma based on the number of levels</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#amescap.FV3_utils.transition" title="amescap.FV3_utils.transition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transition</span></code></a>(pfull[, p_sigma, p_press])</p></td>
<td><p>Return the transition factor to construct <code class="docutils literal notranslate"><span class="pre">ak</span></code> and <code class="docutils literal notranslate"><span class="pre">bk</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#amescap.FV3_utils.swinbank" title="amescap.FV3_utils.swinbank"><code class="xref py py-obj docutils literal notranslate"><span class="pre">swinbank</span></code></a>(plev, psfc[, ptrans])</p></td>
<td><p>Compute <code class="docutils literal notranslate"><span class="pre">ak</span></code> and <code class="docutils literal notranslate"><span class="pre">bk</span></code> values with a transition based on Swinbank</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#amescap.FV3_utils.polar_warming" title="amescap.FV3_utils.polar_warming"><code class="xref py py-obj docutils literal notranslate"><span class="pre">polar_warming</span></code></a>(T, lat[, outside_range])</p></td>
<td><p>Return the polar warming, following McDunn et al. 2013:</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#amescap.FV3_utils.tshift" title="amescap.FV3_utils.tshift"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tshift</span></code></a>(array, lon, timeo[, timex])</p></td>
<td><p>Conversion to uniform local time.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#amescap.FV3_utils.lin_interp" title="amescap.FV3_utils.lin_interp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lin_interp</span></code></a>(X_in, X_ref, Y_ref)</p></td>
<td><p>Simple linear interpolation with no dependance on scipy</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#amescap.FV3_utils.add_cyclic" title="amescap.FV3_utils.add_cyclic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_cyclic</span></code></a>(data, lon)</p></td>
<td><p>Add a cyclic (overlapping) point to a 2D array. Useful for azimuth</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#amescap.FV3_utils.spherical_div" title="amescap.FV3_utils.spherical_div"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spherical_div</span></code></a>(U, V, lon_deg, lat_deg[, R, spacing])</p></td>
<td><p>Compute the divergence of the wind fields using finite difference:</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#amescap.FV3_utils.spherical_curl" title="amescap.FV3_utils.spherical_curl"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spherical_curl</span></code></a>(U, V, lon_deg, lat_deg[, R, spacing])</p></td>
<td><p>Compute the vertical component of the relative vorticity using</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#amescap.FV3_utils.frontogenesis" title="amescap.FV3_utils.frontogenesis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">frontogenesis</span></code></a>(U, V, theta, lon_deg, lat_deg[, R, spacing])</p></td>
<td><p>Compute the frontogenesis (local change in potential temperature</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#amescap.FV3_utils.MGSzmax_ls_lat" title="amescap.FV3_utils.MGSzmax_ls_lat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MGSzmax_ls_lat</span></code></a>(ls, lat)</p></td>
<td><p>Return the max altitude for the dust from &quot;MGS scenario&quot; from</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#amescap.FV3_utils.MGStau_ls_lat" title="amescap.FV3_utils.MGStau_ls_lat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MGStau_ls_lat</span></code></a>(ls, lat)</p></td>
<td><p>Return the max altitude for the dust from &quot;MGS scenario&quot; from</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#amescap.FV3_utils.broadcast" title="amescap.FV3_utils.broadcast"><code class="xref py py-obj docutils literal notranslate"><span class="pre">broadcast</span></code></a>(var_1D, shape_out, axis)</p></td>
<td><p>Broadcast a 1D array based on a variable's dimensions</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#amescap.FV3_utils.ref_atmosphere_Mars_PTD" title="amescap.FV3_utils.ref_atmosphere_Mars_PTD"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ref_atmosphere_Mars_PTD</span></code></a>(Zi)</p></td>
<td><p>Analytical atmospheric model for Martian pressure, temperature, and</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#amescap.FV3_utils.press_to_alt_atmosphere_Mars" title="amescap.FV3_utils.press_to_alt_atmosphere_Mars"><code class="xref py py-obj docutils literal notranslate"><span class="pre">press_to_alt_atmosphere_Mars</span></code></a>(Pi)</p></td>
<td><p>Return the altitude [m] as a function of pressure from the</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#amescap.FV3_utils.azimuth2cart" title="amescap.FV3_utils.azimuth2cart"><code class="xref py py-obj docutils literal notranslate"><span class="pre">azimuth2cart</span></code></a>(LAT, LON, lat0[, lon0])</p></td>
<td><p>Azimuthal equidistant projection. Converts from latitude-longitude</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#amescap.FV3_utils.ortho2cart" title="amescap.FV3_utils.ortho2cart"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ortho2cart</span></code></a>(LAT, LON, lat0[, lon0])</p></td>
<td><p>Orthographic projection. Converts from latitude-longitude to</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#amescap.FV3_utils.mollweide2cart" title="amescap.FV3_utils.mollweide2cart"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mollweide2cart</span></code></a>(LAT, LON)</p></td>
<td><p>Mollweide projection. Converts from latitude-longitude to</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#amescap.FV3_utils.robin2cart" title="amescap.FV3_utils.robin2cart"><code class="xref py py-obj docutils literal notranslate"><span class="pre">robin2cart</span></code></a>(LAT, LON)</p></td>
<td><p>Robinson projection. Converts from latitude-longitude to cartesian</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#amescap.FV3_utils.sol2ls" title="amescap.FV3_utils.sol2ls"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sol2ls</span></code></a>(jld[, cumulative])</p></td>
<td><p>Return the solar longitude (Ls) as a function of the sol number.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#amescap.FV3_utils.ls2sol" title="amescap.FV3_utils.ls2sol"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ls2sol</span></code></a>(Ls_in)</p></td>
<td><p>Ls to sol converter.</p></td>
</tr>
</tbody>
</table>
<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.fms_press_calc">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">fms_press_calc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">psfc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ak</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lev_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'full'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.fms_press_calc" title="Link to this definition"></a></dt>
<dd><p>Returns the 3D pressure field from the surface pressure and the
ak/bk coefficients.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>psfc</strong> (<em>array</em>) – the surface pressure [Pa] or an array of surface
pressures (1D, 2D, or 3D if time dimension)</p></li>
<li><p><strong>ak</strong> (<em>array</em>) – 1st vertical coordinate parameter</p></li>
<li><p><strong>bk</strong> (<em>array:</em>) – 2nd vertical coordinate parameter</p></li>
<li><p><strong>lev_type</strong> (<em>str</em>) – “full” (layer midpoints) or “half”
(layer interfaces). Defaults to “full.”</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the 3D pressure field at the full levels
<code class="docutils literal notranslate"><span class="pre">PRESS_f(Nk-1:,:,:)</span></code> or half-levels <code class="docutils literal notranslate"><span class="pre">PRESS_h(Nk,:,:,)</span></code> [Pa]</p>
</dd>
</dl>
<p>Calculation</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">---</span> <span class="mi">0</span> <span class="o">---</span> <span class="n">TOP</span>        <span class="o">========</span>  <span class="n">p_half</span>
<span class="o">---</span> <span class="mi">1</span> <span class="o">---</span>
                     <span class="o">--------</span>  <span class="n">p_full</span>

                     <span class="o">========</span>  <span class="n">p_half</span>
<span class="o">---</span><span class="n">Nk</span><span class="o">-</span><span class="mi">1</span><span class="o">---</span>           <span class="o">--------</span>  <span class="n">p_full</span>
<span class="o">---</span> <span class="n">Nk</span> <span class="o">---</span> <span class="n">SFC</span>       <span class="o">========</span>  <span class="n">p_half</span>
                    <span class="o">/</span> <span class="o">/</span> <span class="o">/</span> <span class="o">/</span> <span class="o">/</span>
</pre></div>
</div>
<dl class="simple">
<dt>..NOTE:: Some literature uses pk (pressure) instead of ak with</dt><dd><p><code class="docutils literal notranslate"><span class="pre">p3d</span> <span class="pre">=</span> <span class="pre">ps</span> <span class="pre">*</span> <span class="pre">bk</span> <span class="pre">+</span> <span class="pre">P_ref</span> <span class="pre">*</span> <span class="pre">ak</span></code> instead of <code class="docutils literal notranslate"><span class="pre">p3d</span> <span class="pre">=</span> <span class="pre">ps</span> <span class="pre">*</span> <span class="pre">bk</span> <span class="pre">+</span> <span class="pre">ak</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.fms_Z_calc">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">fms_Z_calc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">psfc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ak</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">topo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lev_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'full'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.fms_Z_calc" title="Link to this definition"></a></dt>
<dd><p>Returns the 3D altitude field [m] AGL (or above aeroid).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>psfc</strong> (<em>array</em>) – The surface pressure [Pa] or array of surface
pressures (1D, 2D, or 3D).</p></li>
<li><p><strong>ak</strong> (<em>array</em>) – 1st vertical coordinate parameter</p></li>
<li><p><strong>bk</strong> (<em>array</em>) – 2nd vertical coordinate parameter.</p></li>
<li><p><strong>T</strong> (<em>1D array</em><em> (</em><em>for a single grid point</em><em>) or </em><em>ND array with
VERTICAL AXIS FIRST.</em>) – The air temperature profile. 1D array (for a single grid
point), ND array with VERTICAL AXIS FIRST.</p></li>
<li><p><strong>topo</strong> (<em>array</em>) – The surface elevation. Same dimension as <code class="docutils literal notranslate"><span class="pre">psfc</span></code>.
If None is provided, AGL is returned.</p></li>
<li><p><strong>lev_type</strong> (<em>str</em>) – “full” (layer midpoint) or “half” (layer
interfaces). Defaults to “full”.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the layer altitude at the full level <code class="docutils literal notranslate"><span class="pre">Z_f(:,</span> <span class="pre">:,</span> <span class="pre">Nk-1)</span></code>
or half-level <code class="docutils literal notranslate"><span class="pre">Z_h(:,</span> <span class="pre">:,</span> <span class="pre">Nk)</span></code> [m]. <code class="docutils literal notranslate"><span class="pre">Z_f</span></code> and <code class="docutils literal notranslate"><span class="pre">Z_h</span></code> are
AGL if <code class="docutils literal notranslate"><span class="pre">topo</span> <span class="pre">=</span> <span class="pre">None</span></code>. <code class="docutils literal notranslate"><span class="pre">Z_f</span></code> and <code class="docutils literal notranslate"><span class="pre">Z_h</span></code> are above aeroid
if topography is not None.</p>
</dd>
</dl>
<p>Calculation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">---</span> <span class="mi">0</span> <span class="o">---</span> <span class="n">TOP</span>        <span class="o">========</span>  <span class="n">z_half</span>
<span class="o">---</span> <span class="mi">1</span> <span class="o">---</span>
                    <span class="o">--------</span>  <span class="n">z_full</span>

                    <span class="o">========</span>  <span class="n">z_half</span>
<span class="o">---</span><span class="n">Nk</span><span class="o">-</span><span class="mi">1</span><span class="o">---</span>           <span class="o">--------</span>  <span class="n">z_full</span>
<span class="o">---</span> <span class="n">Nk</span> <span class="o">---</span> <span class="n">SFC</span>       <span class="o">========</span>  <span class="n">z_half</span>
                    <span class="o">/</span> <span class="o">/</span> <span class="o">/</span> <span class="o">/</span> <span class="o">/</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Expands to the time dimension using:</p>
<p>topo = np.repeat(zsurf[np.newaxis, :], ps.shape[0], axis = 0)</p>
</div>
<p>..NOTE:: Expands topo to the time dimension using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">topo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">zsurf</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span> <span class="n">ps</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Calculation is derived from
<code class="docutils literal notranslate"><span class="pre">./atmos_cubed_sphere_mars/Mars_phys.F90</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">dp</span><span class="o">/</span><span class="n">dz</span> <span class="o">=</span> <span class="o">-</span><span class="n">rho</span> <span class="n">g</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">dz</span> <span class="o">=</span> <span class="n">dp</span><span class="o">/</span><span class="p">(</span><span class="o">-</span><span class="n">rho</span> <span class="n">g</span><span class="p">))</span> <span class="ow">and</span>
<span class="p">(</span><span class="n">rho</span><span class="o">=</span> <span class="n">p</span><span class="o">/</span><span class="p">(</span><span class="n">r</span> <span class="n">T</span><span class="p">))</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">dz</span><span class="o">=</span><span class="n">rT</span><span class="o">/</span><span class="n">g</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">dp</span><span class="o">/</span><span class="n">p</span><span class="p">))</span>

<span class="c1"># Define log-pressure (``u``) as:</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">ln</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

<span class="c1"># Then:</span>
<span class="n">du</span> <span class="o">=</span> <span class="p">{</span><span class="n">du</span><span class="o">/</span><span class="n">dp</span><span class="p">}</span><span class="o">*</span><span class="n">dp</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="o">/</span><span class="n">p</span><span class="p">)</span><span class="o">*</span><span class="n">dp</span><span class="p">}</span> <span class="o">=</span> <span class="n">dp</span><span class="o">/</span><span class="n">p</span>

<span class="c1"># Finally, ``dz`` for the half-layers:</span>
<span class="p">(</span><span class="n">dz</span> <span class="o">=</span> <span class="n">rT</span><span class="o">/</span><span class="n">g</span> <span class="o">*</span> <span class="o">-</span><span class="p">(</span><span class="n">du</span><span class="p">))</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">dz</span> <span class="o">=</span> <span class="n">rT</span><span class="o">/</span><span class="n">g</span> <span class="o">*</span><span class="p">(</span><span class="o">+</span><span class="n">dp</span><span class="o">/</span><span class="n">p</span><span class="p">))</span>
<span class="c1"># with ``N`` layers defined from top to bottom.</span>
</pre></div>
</div>
<p>Z_half calculation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Hydrostatic</span> <span class="n">relation</span>
<span class="n">within</span> <span class="n">the</span> <span class="n">layer</span>        <span class="o">&gt;</span>   <span class="p">(</span><span class="n">P</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">P</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">DZ</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">/</span><span class="n">H</span><span class="p">))</span>
<span class="c1"># layer thickness</span>
<span class="n">DZ</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="n">rT</span><span class="o">/</span><span class="n">g</span> <span class="o">*</span> <span class="o">-</span><span class="p">(</span><span class="n">du</span><span class="p">)</span>
<span class="c1"># previous layer altitude + thickness of layer</span>
<span class="n">Z_h</span> <span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="n">Z_h</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="o">+</span><span class="n">DZ_h</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
</pre></div>
</div>
<p>Z_full calculation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># previous altitude + half the thickness of previous layer and</span>
<span class="c1"># half of current layer</span>
<span class="n">Z_f</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="n">Z_f</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mf">0.5</span> <span class="n">DZ</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="n">DZ</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
<span class="c1"># Add ``+0.5 DZ(k)-0.5 DZ(k)=0`` and re-organiz the equation</span>
<span class="n">Z_f</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="n">Z_f</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">DZ</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="p">(</span><span class="n">DZ</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">DZ</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
<span class="n">Z_f</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">=</span> <span class="n">Z_h</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="p">(</span><span class="n">DZ</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">DZ</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
</pre></div>
</div>
<p>The specific heat ratio:
<code class="docutils literal notranslate"><span class="pre">γ</span> <span class="pre">=</span> <span class="pre">cp/cv</span> <span class="pre">(cv</span> <span class="pre">=</span> <span class="pre">cp-R)</span></code> =&gt; <code class="docutils literal notranslate"><span class="pre">γ</span> <span class="pre">=</span> <span class="pre">cp/(cp-R)</span></code> Also <code class="docutils literal notranslate"><span class="pre">(γ-1)/γ=R/cp</span></code>
The dry adiabatic lapse rate:
<code class="docutils literal notranslate"><span class="pre">Γ</span> <span class="pre">=</span> <span class="pre">g/cp</span></code> =&gt; <code class="docutils literal notranslate"><span class="pre">Γ</span> <span class="pre">=</span> <span class="pre">(gγ)/R</span></code>
The isentropic relation:
<code class="docutils literal notranslate"><span class="pre">T2</span> <span class="pre">=</span> <span class="pre">T1(p2/p1)**(R/cp)</span></code></p>
<p>therefore:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">line</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=====</span><span class="n">Thalf</span><span class="o">=====</span><span class="n">zhalf</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>          <span class="n">line</span> <span class="mi">2</span><span class="p">)</span>                                   <span class="n">line</span> <span class="mi">3</span><span class="p">)</span>                                    <span class="n">line</span> <span class="mi">4</span><span class="p">)</span> <span class="o">-----</span><span class="n">Tfull</span><span class="o">-----</span><span class="n">zfull</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>     \ <span class="n">T</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">=</span> <span class="n">To</span><span class="o">-</span><span class="n">Γ</span> <span class="p">(</span><span class="n">z</span><span class="o">-</span><span class="n">zo</span><span class="p">)</span>
<span class="n">line</span> <span class="mi">5</span><span class="p">)</span>                                      <span class="n">line</span> <span class="mi">6</span><span class="p">)</span>                                       <span class="n">line</span> <span class="mi">7</span><span class="p">)</span> <span class="o">=====</span><span class="n">Thalf</span><span class="o">=====</span><span class="n">zhalf</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>Line 1: T_half[k+1]/Tfull[k] = (p_half[k+1]/p_full[k])**(R/Cp)</p>
<dl>
<dt>Line 4: From the lapse rate, assume T decreases linearly within the</dt><dd><p>layer so <code class="docutils literal notranslate"><span class="pre">T_half[k+1]</span> <span class="pre">=</span> <span class="pre">T_full[k]</span> <span class="pre">+</span> <span class="pre">Γ(Z_full[k]-Z_half[k+1])</span></code>
and (<code class="docutils literal notranslate"><span class="pre">Tfull</span> <span class="pre">&lt;</span> <span class="pre">Thalf</span></code> and <code class="docutils literal notranslate"><span class="pre">Γ</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>)</p>
</dd>
<dt>Line 7: <code class="docutils literal notranslate"><span class="pre">Z_full[k]</span> <span class="pre">=</span> <span class="pre">Z_half[k]</span> <span class="pre">+</span> <span class="pre">(T_half[k+1]-T_full[k])/Γ</span></code></dt><dd><p>Pulling out <code class="docutils literal notranslate"><span class="pre">Tfull</span></code> from above equation and using
<code class="docutils literal notranslate"><span class="pre">Γ</span> <span class="pre">=</span> <span class="pre">(gγ)/R</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Z_full</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Z_half</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">R</span> <span class="n">Tfull</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">gγ</span><span class="p">)(</span><span class="n">T_half</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
             <span class="o">/</span> <span class="n">T_full</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>Using the isentropic relation above:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Z_full</span> <span class="o">=</span> <span class="p">(</span><span class="n">Z_half</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">R</span> <span class="n">Tfull</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">gγ</span><span class="p">)(</span><span class="n">p_half</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
          <span class="o">/</span> <span class="n">p_full</span><span class="p">[</span><span class="n">k</span><span class="p">])</span><span class="o">**</span><span class="p">(</span><span class="n">R</span><span class="o">/</span><span class="n">Cp</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.find_n0">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">find_n0</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Lfull_IN</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Llev_OUT</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse_input</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.find_n0" title="Link to this definition"></a></dt>
<dd><p>Return the index for the level(s) just below <code class="docutils literal notranslate"><span class="pre">Llev_OUT</span></code>.
This assumes <code class="docutils literal notranslate"><span class="pre">Lfull_IN</span></code> is increasing in the array
(e.g., <code class="docutils literal notranslate"><span class="pre">p(0)</span> <span class="pre">=</span> <span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">p(N)</span> <span class="pre">=</span> <span class="pre">1000</span></code> [Pa]).</p>
<dl class="simple">
<dt>:param Lfull_IN:input pressure [pa] or altitude [m] at layer</dt><dd><p>midpoints. <code class="docutils literal notranslate"><span class="pre">Level</span></code> dimension is FIRST.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Llev_OUT</strong> (<em>float</em><em> or </em><em>1D array</em>) – desired level type for interpolation [Pa] or [m].</p></li>
<li><p><strong>reverse_input</strong> (<em>bool</em>) – reverse array (e.g., if <code class="docutils literal notranslate"><span class="pre">z(0)</span> <span class="pre">=</span> <span class="pre">120</span> <span class="pre">km</span></code>,
<code class="docutils literal notranslate"><span class="pre">z(N)</span> <span class="pre">=</span> <span class="pre">0km</span></code> – which is typical – or if input data is
<code class="docutils literal notranslate"><span class="pre">p(0)</span> <span class="pre">=</span> <span class="pre">1000Pa</span></code>, <code class="docutils literal notranslate"><span class="pre">p(N)</span> <span class="pre">=</span> <span class="pre">0Pa</span></code>).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">n</span></code> index for the level(s) where the pressure is just</p>
</dd>
</dl>
<p>below <code class="docutils literal notranslate"><span class="pre">plev</span></code>.</p>
<dl class="simple">
<dt>..NOTE:: If <code class="docutils literal notranslate"><span class="pre">Lfull_IN</span></code> is a 1D array and <code class="docutils literal notranslate"><span class="pre">Llev_OUT</span></code> is a float</dt><dd><p>then <code class="docutils literal notranslate"><span class="pre">n</span></code> is a float.</p>
</dd>
<dt>..NOTE:: If <code class="docutils literal notranslate"><span class="pre">Lfull_IN</span></code> is ND <code class="docutils literal notranslate"><span class="pre">[lev,</span> <span class="pre">time,</span> <span class="pre">lat,</span> <span class="pre">lon]</span></code> and</dt><dd><p><code class="docutils literal notranslate"><span class="pre">Llev_OUT</span></code> is a 1D array of size <code class="docutils literal notranslate"><span class="pre">klev</span></code> then <code class="docutils literal notranslate"><span class="pre">n</span></code> is an
array of size <code class="docutils literal notranslate"><span class="pre">[klev,</span> <span class="pre">Ndim]</span></code> with <code class="docutils literal notranslate"><span class="pre">Ndim</span> <span class="pre">=</span> <span class="pre">[time,</span> <span class="pre">lat,</span> <span class="pre">lon]</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.find_n">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">find_n</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X_IN</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_OUT</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse_input</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">modulo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.find_n" title="Link to this definition"></a></dt>
<dd><p>Maps the closest index from a 1D input array to a ND output array
just below the input values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X_IN</strong> (<em>float</em><em> or </em><em>1D array</em>) – source level [Pa] or [m]</p></li>
<li><p><strong>X_OUT</strong> (<em>array</em>) – desired pressure [Pa] or altitude [m] at layer
midpoints. Level dimension is FIRST.</p></li>
<li><p><strong>reverse_input:</strong> – if input array is decreasing (e.g., if z(0)
= 120 km, z(N) = 0 km, which is typical, or if data is
p(0) = 1000 Pa, p(N) = 0 Pa, which is uncommon)</p></li>
</ul>
</dd>
</dl>
<p>n is the index for the level(s) where the pressure &lt; <code class="docutils literal notranslate"><span class="pre">plev</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Case</span> <span class="mi">1</span><span class="p">:</span>       <span class="n">Case</span> <span class="mi">2</span><span class="p">:</span>      <span class="n">Case</span> <span class="mi">3</span><span class="p">:</span>       <span class="n">Case</span> <span class="mi">4</span><span class="p">:</span>
<span class="p">(</span><span class="n">ND</span><span class="p">)</span>   <span class="p">(</span><span class="mi">1</span><span class="n">D</span><span class="p">)</span>   <span class="p">(</span><span class="mi">1</span><span class="n">D</span><span class="p">)</span>  <span class="p">(</span><span class="mi">1</span><span class="n">D</span><span class="p">)</span>   <span class="p">(</span><span class="mi">1</span><span class="n">D</span><span class="p">)</span>  <span class="p">(</span><span class="n">ND</span><span class="p">)</span>    <span class="p">(</span><span class="n">ND</span><span class="p">)</span>    <span class="p">(</span><span class="n">ND</span><span class="p">)</span>
<span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="n">x</span><span class="o">|</span>         <span class="o">|</span><span class="n">x</span><span class="o">|</span>          <span class="o">|</span><span class="n">x</span><span class="o">|</span>           <span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="n">x</span><span class="o">|</span>
<span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="o">&gt;</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>   <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="o">&gt;</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>    <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="o">&gt;</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="n">x</span><span class="o">|</span>   <span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="o">&gt;</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="n">x</span><span class="o">|</span>
<span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="n">x</span><span class="o">|</span>   <span class="o">|</span><span class="n">x</span><span class="o">|</span>   <span class="o">|</span><span class="n">x</span><span class="o">|</span>   <span class="o">|</span><span class="n">x</span><span class="o">|</span>    <span class="o">|</span><span class="n">x</span><span class="o">|</span>   <span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="n">x</span><span class="o">|</span>   <span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="n">x</span><span class="o">|</span>   <span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="n">x</span><span class="o">|</span>
<span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="n">x</span><span class="o">|</span>   <span class="o">|</span><span class="n">x</span><span class="o">|</span>   <span class="o">|</span><span class="n">x</span><span class="o">|</span>   <span class="o">|</span><span class="n">x</span><span class="o">|</span>    <span class="o">|</span><span class="n">x</span><span class="o">|</span>   <span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="n">x</span><span class="o">|</span>   <span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="n">x</span><span class="o">|</span>   <span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="n">x</span><span class="o">|</span>
<span class="n">Case</span> <span class="mi">4</span> <span class="n">must</span> <span class="n">have</span> <span class="n">same</span> <span class="n">number</span> <span class="n">of</span> <span class="n">elements</span> <span class="n">along</span> <span class="n">the</span> <span class="n">other</span>
<span class="n">dimensions</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Cyclic arrays are handled naturally (e.g., time of day
0.5 …23.5 &gt; 0.5 or longitudes 0 &gt; …359 &gt; 0). If the first
array element &gt; requested value, (e.g., requested = 0.2,
array = [0.5, 1.5, …, 23.5]), then n = 0-1 = -1 which is the
last element in the array (23.5).</p>
<p>The last element in the array is always &lt;= the selected value:
e.g., requested = 23.8, array = [0.5, 1.5, …, 23.5] then the
returned value is 23.5.</p>
<p>Therefore, the cyclic values must be handled during the
interpolation stage (i.e., before this stage).</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.expand_index">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">expand_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Nindex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">VAR_shape_axis_FIRST</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis_list</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.expand_index" title="Link to this definition"></a></dt>
<dd><p>Repeat interpolation indices along an axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Nindex</strong> (<em>idx</em>) – inteprolation indices, size is (<code class="docutils literal notranslate"><span class="pre">n_axis</span></code>,
<code class="docutils literal notranslate"><span class="pre">Nfull</span> <span class="pre">=</span> <span class="pre">[time,</span> <span class="pre">lat,</span> <span class="pre">lon]</span></code>)</p></li>
<li><p><strong>VAR_shape_axis_FIRST</strong> (<em>tuple</em>) – shape for the variable to interpolate
with interpolation axis first (e.g., <code class="docutils literal notranslate"><span class="pre">[tod,</span> <span class="pre">time,</span> <span class="pre">lev,</span> <span class="pre">lat,</span> <span class="pre">lon]</span></code>)</p></li>
<li><p><strong>axis_list</strong> (<em>int</em><em> or </em><em>list</em>) – position or list of positions for
axis to insert (e.g., <code class="docutils literal notranslate"><span class="pre">2</span></code> for <code class="docutils literal notranslate"><span class="pre">lev</span></code> in
<code class="docutils literal notranslate"><span class="pre">[tod,</span> <span class="pre">time,</span> <span class="pre">lev,</span> <span class="pre">lat,</span> <span class="pre">lon]</span></code>, <code class="docutils literal notranslate"><span class="pre">[2,</span> <span class="pre">4]</span></code> for <code class="docutils literal notranslate"><span class="pre">lev</span></code> and
<code class="docutils literal notranslate"><span class="pre">lon</span></code>. The axis position are those for the final shape
(<code class="docutils literal notranslate"><span class="pre">VAR_shape_axis_FIRST</span></code>) and must be INCREASING</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">LFULL</span></code> a 2D array (size <code class="docutils literal notranslate"><span class="pre">n_axis</span></code>,</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">NfFULL</span> <span class="pre">=</span> <span class="pre">[time,</span> <span class="pre">lev,</span> <span class="pre">lat,</span> <span class="pre">lon])</span></code> with the indices expanded
along the <code class="docutils literal notranslate"><span class="pre">lev</span></code> dimension and flattened</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Example of application:
Observational time of day may the same at all vertical levels
so the interpolation of a 5D variable
<code class="docutils literal notranslate"><span class="pre">[tod,</span> <span class="pre">time,</span> <span class="pre">lev,</span> <span class="pre">lat,</span> <span class="pre">lon]</span></code> only requires the interpolation
indices for <code class="docutils literal notranslate"><span class="pre">[tod,</span> <span class="pre">time,</span> <span class="pre">lat,</span> <span class="pre">lon]</span></code>. This routines expands
the indices from <code class="docutils literal notranslate"><span class="pre">[tod,</span> <span class="pre">time,</span> <span class="pre">lat,</span> <span class="pre">lon]</span></code> to
<code class="docutils literal notranslate"><span class="pre">[tod,</span> <span class="pre">time,</span> <span class="pre">lev,</span> <span class="pre">lat,</span> <span class="pre">lon]</span></code> with
<code class="docutils literal notranslate"><span class="pre">Nfull</span> <span class="pre">=</span> <span class="pre">[time,</span> <span class="pre">lev,</span> <span class="pre">lat,</span> <span class="pre">lon]</span></code> for use in interpolation.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.vinterp">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">vinterp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">varIN</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Lfull</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Llev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type_int</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'log'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse_input</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">masktop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.vinterp" title="Link to this definition"></a></dt>
<dd><p>Vertical linear or logarithmic interpolation for pressure or
altitude. Alex Kling 5-27-20</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>varIN</strong> (<em>ND array</em>) – variable to interpolate (VERTICAL AXIS FIRST)</p></li>
<li><p><strong>Lfull</strong> (<em>array</em>) – pressure [Pa] or altitude [m] at full layers same
dimensions as <code class="docutils literal notranslate"><span class="pre">varIN</span></code></p></li>
<li><p><strong>Llev</strong> (<em>1D array</em>) – desired level for interpolation [Pa] or [m]. May be
increasing or decreasing as the output levels are processed one
at the time.</p></li>
<li><p><strong>reverse_input</strong> (<em>bool</em>) – reverse input arrays. e.g, if
<code class="docutils literal notranslate"><span class="pre">zfull[0]</span></code> = 120 km then <code class="docutils literal notranslate"><span class="pre">zfull[N]</span></code> = 0km (typical) or if
input data is <a href="#id1"><span class="problematic" id="id2">``</span></a>pfull[0]``=1000 Pa, <a href="#id3"><span class="problematic" id="id4">``</span></a>pfull[N]``=0 Pa</p></li>
<li><p><strong>type_int</strong> (<em>str</em>) – “log” for logarithmic (typically pressure),
“lin” for linear (typically altitude)</p></li>
<li><p><strong>masktop</strong> – set to NaN values if above the model top</p></li>
<li><p><strong>masktop</strong> – bool</p></li>
<li><p><strong>index</strong> – indices for the interpolation, already processed as
<code class="docutils literal notranslate"><span class="pre">[klev,</span> <span class="pre">Ndim]</span></code>. Indices calculated if not provided.</p></li>
<li><p><strong>index</strong> – None or array</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">varOUT</span></code> variable interpolated on the <code class="docutils literal notranslate"><span class="pre">Llev</span></code> pressure
or altitude levels</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This interpolation assumes pressure decreases w/height:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">--</span>  <span class="mi">0</span>  <span class="o">--</span> <span class="n">TOP</span>  <span class="p">[</span><span class="mi">0</span> <span class="n">Pa</span><span class="p">]</span>   <span class="p">:</span> <span class="p">[</span><span class="mi">120</span> <span class="n">km</span><span class="p">]</span><span class="o">|</span> <span class="n">X_OUT</span> <span class="o">=</span> <span class="n">Xn</span><span class="o">*</span><span class="n">A</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">A</span><span class="p">)</span><span class="o">*</span><span class="n">Xn</span> <span class="o">+</span> <span class="mi">1</span>
<span class="o">--</span>  <span class="mi">1</span>  <span class="o">--</span>               <span class="p">:</span>         <span class="o">|</span>
                        <span class="p">:</span>         <span class="o">|</span>
<span class="o">--</span>  <span class="n">n</span>  <span class="o">--</span> <span class="n">pn</span>   <span class="p">[</span><span class="mi">30</span> <span class="n">Pa</span><span class="p">]</span>  <span class="p">:</span> <span class="p">[</span><span class="mi">800</span> <span class="n">m</span><span class="p">]</span> <span class="o">|</span> <span class="n">Xn</span>
                        <span class="p">:</span>         <span class="o">|</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="o">--</span>  <span class="n">k</span>  <span class="o">--</span> <span class="n">Llev</span> <span class="p">[</span><span class="mi">100</span> <span class="n">Pa</span><span class="p">]</span> <span class="p">:</span> <span class="p">[</span><span class="mi">500</span> <span class="n">m</span><span class="p">]</span> <span class="o">|</span> <span class="n">X_OUT</span>
<span class="go">    -- n+1 -- pn+1 [200 Pa] : [200 m] | Xn+1</span>
</pre></div>
</div>
<blockquote>
<div><p>– SFC –
/ / / / / /</p>
</div></blockquote>
<p>with <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">log(Llev/pn</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">/</span> <span class="pre">log(pn/pn</span> <span class="pre">+</span> <span class="pre">1)</span></code> in “log” mode
or <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">=</span> <span class="pre">(zlev-zn</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">/</span> <span class="pre">(zn-zn</span> <span class="pre">+</span> <span class="pre">1)</span></code> in “lin” mode</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.axis_interp">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">axis_interp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var_IN</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse_input</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type_int</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'lin'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">modulo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.axis_interp" title="Link to this definition"></a></dt>
<dd><p>One dimensional linear/logarithmic interpolation along one axis.
Alex Kling, May 2021</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var_IN</strong> (<em>ND array</em>) – variable on a REGULAR grid (e.g.,
<code class="docutils literal notranslate"><span class="pre">[lev,</span> <span class="pre">lat,</span> <span class="pre">lon]</span></code> or <code class="docutils literal notranslate"><span class="pre">[time,</span> <span class="pre">lev,</span> <span class="pre">lat,</span> <span class="pre">lon]</span></code>).</p></li>
<li><p><strong>x</strong> (<em>1D array</em>) – original position array (e.g., <code class="docutils literal notranslate"><span class="pre">time</span></code>)</p></li>
<li><p><strong>xi</strong> (<em>1D array</em>) – target array to interpolate the array on</p></li>
<li><p><strong>axis</strong> (<em>int</em>) – position of the interpolation axis (e.g., <code class="docutils literal notranslate"><span class="pre">0</span></code> for a
temporal interpolation on <code class="docutils literal notranslate"><span class="pre">[time,</span> <span class="pre">lev,</span> <span class="pre">lat,</span> <span class="pre">lon]</span></code>)</p></li>
<li><p><strong>reverse_input</strong> (<em>bool</em>) – reverse input arrays (e.g., if
<a href="#id5"><span class="problematic" id="id6">``</span></a>zfull(0)``= 120 km, <a href="#id7"><span class="problematic" id="id8">``</span></a>zfull(N)``= 0 km, which is typical)</p></li>
<li><p><strong>type_int</strong> (<em>str</em>) – “log” for logarithmic (typically pressure),
“lin” for linear</p></li>
<li><p><strong>modulo</strong> (<em>float</em>) – for “lin” interpolation only, use cyclic input
(e.g., when using <code class="docutils literal notranslate"><span class="pre">modulo</span> <span class="pre">=</span> <span class="pre">24</span></code> for time of day, 23.5 and
00 am are considered 30 min apart, not 23.5 hr apart.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">VAR_OUT</span></code> interpolated data on the requested axis</p>
</dd>
</dl>
<dl>
<dt>..NOTE :: This routine is similar but simpler than the vertical</dt><dd><p>interpolation <code class="docutils literal notranslate"><span class="pre">vinterp()</span></code> as the interpolation axis is
assumed to be fully defined by a 1D array such as <code class="docutils literal notranslate"><span class="pre">time</span></code>,
<code class="docutils literal notranslate"><span class="pre">pstd</span></code> or <code class="docutils literal notranslate"><span class="pre">zstd</span></code> rather than 3D arrays like <code class="docutils literal notranslate"><span class="pre">pfull</span></code> or
<code class="docutils literal notranslate"><span class="pre">zfull</span></code>.</p>
<p>For lon/lat interpolation, consider using <code class="docutils literal notranslate"><span class="pre">interp_KDTree()</span></code>.</p>
</dd>
</dl>
<p>Calculation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>X_OUT = Xn*A + (1-A)*Xn + 1
with ``A = log(xi/xn + 1) / log(xn/xn + 1)`` in &quot;log&quot; mode
or ``A = (xi-xn + 1)/(xn-xn + 1)`` in &quot;lin&quot; mode
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.layers_mid_point_to_boundary">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">layers_mid_point_to_boundary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pfull</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sfc_val</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.layers_mid_point_to_boundary" title="Link to this definition"></a></dt>
<dd><p>A general description for the layer boundaries is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p_half</span> <span class="o">=</span> <span class="n">ps</span><span class="o">*</span><span class="n">bk</span> <span class="o">+</span> <span class="n">pk</span>
</pre></div>
</div>
<p>This routine converts the coordinate of the
layer MIDPOINTS, <code class="docutils literal notranslate"><span class="pre">p_full</span></code> or <code class="docutils literal notranslate"><span class="pre">bk</span></code>, into the coordinate of the
layer BOUNDARIES <code class="docutils literal notranslate"><span class="pre">p_half</span></code>. The surface value must be provided.
Alex Kling, 2022</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p_full</strong> (<em>1D array</em>) – presure/sigma values for the layer MIDPOINTS,
INCREASING with <code class="docutils literal notranslate"><span class="pre">N</span></code> (e.g., [0.01 -&gt; 720] or [0.001 -&gt; 1]).</p></li>
<li><p><strong>sfc_val</strong> (<em>float</em>) – the surface value for the lowest layer’s boundary
<code class="docutils literal notranslate"><span class="pre">p_half[N]</span></code> (e.g., <code class="docutils literal notranslate"><span class="pre">sfc_val</span></code> = 720 Pa or <code class="docutils literal notranslate"><span class="pre">sfc_val</span></code> = 1. in
sigma coordinates)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">p_half</span></code> the pressure at the layer boundaries
(size = <code class="docutils literal notranslate"><span class="pre">N+1</span></code>)</p>
</dd>
</dl>
<p>Structure:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">---</span> <span class="mi">0</span> <span class="o">---</span> <span class="n">TOP</span>   <span class="o">========</span>  <span class="n">p_half</span>
<span class="o">---</span> <span class="mi">1</span> <span class="o">---</span>
                <span class="o">--------</span>  <span class="n">p_full</span>

                <span class="o">========</span>  <span class="n">p_half</span>
<span class="o">---</span><span class="n">Nk</span><span class="o">-</span><span class="mi">1</span><span class="o">---</span>      <span class="o">--------</span>  <span class="n">p_full</span>
<span class="o">---</span> <span class="n">Nk</span> <span class="o">---</span> <span class="n">SFC</span>  <span class="o">========</span>  <span class="n">p_half</span>
                <span class="o">/</span> <span class="o">/</span> <span class="o">/</span> <span class="o">/</span> <span class="o">/</span>
</pre></div>
</div>
<p>We have:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pfull</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">phalf</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="o">-</span><span class="n">phalf</span><span class="p">[</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
             <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">phalf</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="o">/</span><span class="n">phalf</span><span class="p">[</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
<span class="o">=&gt;</span> <span class="n">phalf</span><span class="p">[</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pfull</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="n">log</span><span class="p">(</span><span class="n">phalf</span><span class="p">[</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="o">=</span> <span class="n">phalf</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">-</span> <span class="n">pfull</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="n">log</span><span class="p">(</span><span class="n">phalf</span><span class="p">[</span><span class="n">N</span><span class="p">])</span>
</pre></div>
</div>
<dl class="simple">
<dt>We want to solve for <code class="docutils literal notranslate"><span class="pre">phalf[N-1]</span> <span class="pre">=</span> <span class="pre">X</span></code>::</dt><dd><p>v                v                             v
X      - pfull[N]       log(X)   =             B</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">=&gt;</span> <span class="pre">X=</span> <span class="pre">-pfull[N]</span> <span class="pre">W{-exp(-B/pfull[N])/pfull[N]}</span></code>
with <code class="docutils literal notranslate"><span class="pre">B</span> <span class="pre">=</span> <span class="pre">phalf[N]</span> <span class="pre">-</span> <span class="pre">pfull[N]</span> <span class="pre">log(phalf[N])</span></code> (known at N) and
<code class="docutils literal notranslate"><span class="pre">W</span></code> is the product-log (Lambert) function.</p>
<p>Though the product-log function is available in python, we use an
approximation for portability (see appendix in Kling et al. 2020,
Icarus).</p>
<p>This was tested on an L30 simulation: The values of <code class="docutils literal notranslate"><span class="pre">phalf</span></code> are
reconstruted from <code class="docutils literal notranslate"><span class="pre">pfull</span></code> with a max error of
<code class="docutils literal notranslate"><span class="pre">100*(phalf</span> <span class="pre">-</span> <span class="pre">phalf_reconstruct)/phalf</span> <span class="pre">&lt;</span> <span class="pre">0.4%</span></code> at the top.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.polar2XYZ">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">polar2XYZ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Re</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3400</span> <span class="pre">*</span> <span class="pre">10**3</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.polar2XYZ" title="Link to this definition"></a></dt>
<dd><p>Spherical to cartesian coordinate transformation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lon</strong> (<em>ND array</em>) – longitude in radians</p></li>
<li><p><strong>lat</strong> (<em>ND array</em>) – latitude in radians</p></li>
<li><p><strong>alt</strong> (<em>ND array</em>) – altitude [m]</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">X</span></code>, <code class="docutils literal notranslate"><span class="pre">Y</span></code>, <code class="docutils literal notranslate"><span class="pre">Z</span></code> in cartesian coordinates [m]</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is a classic polar coordinate system with
<code class="docutils literal notranslate"><span class="pre">colatitude</span> <span class="pre">=</span> <span class="pre">pi/2</span> <span class="pre">-</span> <span class="pre">lat</span></code> where <code class="docutils literal notranslate"><span class="pre">cos(colat)</span> <span class="pre">=</span> <span class="pre">sin(lat)</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.interp_KDTree">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">interp_KDTree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var_IN</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat_IN</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lon_IN</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat_OUT</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lon_OUT</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N_nearest</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.interp_KDTree" title="Link to this definition"></a></dt>
<dd><p>Inverse distance-weighted interpolation using nearest neighboor for
ND variables. Alex Kling, May 2021</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var_IN</strong> (<em>ND array</em>) – ND variable to regrid (e.g., <code class="docutils literal notranslate"><span class="pre">[lev,</span> <span class="pre">lat,</span> <span class="pre">lon]</span></code>,
<code class="docutils literal notranslate"><span class="pre">[time,</span> <span class="pre">lev,</span> <span class="pre">lat,</span> <span class="pre">lon]</span></code> with <code class="docutils literal notranslate"><span class="pre">[lat,</span> <span class="pre">lon]</span></code> dimensions LAST
[°])</p></li>
<li><p><strong>lat_IN</strong> (<em>1D</em><em> or </em><em>2D array</em>) – latitude [°] (<code class="docutils literal notranslate"><span class="pre">LAT[y,</span> <span class="pre">x]</span></code> array for
irregular grids)</p></li>
<li><p><strong>lon_IN</strong> (<em>1D</em><em> or </em><em>2D array</em>) – latitude [°] (<code class="docutils literal notranslate"><span class="pre">LAT[y,</span> <span class="pre">x]</span></code> array for
irregular grids)</p></li>
<li><p><strong>lat_OUT</strong> (<em>1D</em><em> or </em><em>2D array</em>) – latitude [°] for the TARGET grid structure
(or <code class="docutils literal notranslate"><span class="pre">LAT1[y,x]</span></code> for irregular grids)</p></li>
<li><p><strong>lon_OUT</strong> (<em>1D</em><em> or </em><em>2D array</em>) – longitude [°] for the TARGET grid structure
(or <code class="docutils literal notranslate"><span class="pre">LON1[y,x]</span></code> for irregular grids)</p></li>
<li><p><strong>N_nearest</strong> (<em>int</em>) – number of nearest neighbours for the search</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">VAR_OUT</span></code> interpolated data on the target grid</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This implementation is much FASTER than <code class="docutils literal notranslate"><span class="pre">griddata</span></code> and
it supports unstructured grids like an MGCM tile.</p>
<p>The nearest neighbour interpolation is only done on the lon/lat
axis (not level). Although this interpolation works well on the
3D field [x, y, z], this is typically not what is expected. In
a 4°x4° run, the closest points in all directions (N, E, S, W)
on the target grid are 100’s of km away while the closest
points in the vertical are a few 10’s -100’s meter in the PBL.
This would result in excessive weighting in the vertical.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.cart_to_azimut_TR">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">cart_to_azimut_TR</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'from'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.cart_to_azimut_TR" title="Link to this definition"></a></dt>
<dd><p>Convert cartesian coordinates or wind vectors to radians using
azimuth angle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>1D array</em>) – the cartesian coordinate</p></li>
<li><p><strong>y</strong> (<em>1D array</em>) – the cartesian coordinate</p></li>
<li><p><strong>mode</strong> (<em>str</em>) – “to” for the direction that the vector is pointing,
“from” for the direction from which the vector is coming</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">Theta</span></code> [°] and <code class="docutils literal notranslate"><span class="pre">R</span></code> the polar coordinates</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.sfc_area_deg">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">sfc_area_deg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lon1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lon2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3390000.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.sfc_area_deg" title="Link to this definition"></a></dt>
<dd><p>Return the surface between two sets of latitudes/longitudes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">S</span> <span class="o">=</span> <span class="nb">int</span><span class="p">[</span><span class="n">R</span><span class="o">^</span><span class="mi">2</span> <span class="n">dlon</span> <span class="n">cos</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span> <span class="n">dlat</span><span class="p">]</span>     <span class="n">_____lat2</span>
                                    \                                                 \<span class="n">____</span>\<span class="n">lat1</span>
                                     <span class="n">lon1</span>    <span class="n">lon2</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lon1</strong> (<em>float</em>) – longitude from set 1 [°]</p></li>
<li><p><strong>lon2</strong> (<em>float</em>) – longitude from set 2 [°]</p></li>
<li><p><strong>lat1</strong> (<em>float</em>) – latitude from set 1 [°]</p></li>
<li><p><strong>lat2</strong> (<em>float</em>) – longitude from set 2 [°]</p></li>
<li><p><strong>R</strong> (<em>int</em>) – planetary radius [m]</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Lon and Lat define the corners of the area not the grid
cell center.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.area_meridional_cells_deg">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">area_meridional_cells_deg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lat_c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dlon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dlat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3390000.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.area_meridional_cells_deg" title="Link to this definition"></a></dt>
<dd><p>Return area of invidual cells for a meridional band of thickness
<code class="docutils literal notranslate"><span class="pre">dlon</span></code> where <code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">=</span> <span class="pre">int[R^2</span> <span class="pre">dlon</span> <span class="pre">cos(lat)</span> <span class="pre">dlat]</span></code> with
<code class="docutils literal notranslate"><span class="pre">sin(a)-sin(b)</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">cos((a+b)/2)sin((a+b)/2)</span></code>
so <code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">R^2</span> <span class="pre">dlon</span> <span class="pre">2cos(lat)sin(dlat/2)</span></code></p>
<blockquote>
<div><p>_________lat + dlat/2
   lat               ^</p>
<blockquote>
<div><dl class="simple">
<dt>lon +                | dlat</dt><dd><p>________lat - dlat/2 v</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<dl class="simple">
<dt>lon - dlon/2   lon + dlon/2</dt><dd><dl class="simple">
<dt>&lt;——&gt;</dt><dd><p>dlon</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lat_c</strong> (<em>float</em>) – latitude of cell center [°]</p></li>
<li><p><strong>dlon</strong> (<em>float</em>) – cell angular width [°]</p></li>
<li><p><strong>dlat</strong> (<em>float</em>) – cell angular height [°]</p></li>
<li><p><strong>R</strong> (<em>float</em>) – planetary radius [m]</p></li>
<li><p><strong>normalize</strong> (<em>bool</em>) – if True, the sum of the output elements = 1</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">S</span></code> areas of the cells, same size as <code class="docutils literal notranslate"><span class="pre">lat_c</span></code> in [m2]
or normalized by the total area</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.area_weights_deg">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">area_weights_deg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat_c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.area_weights_deg" title="Link to this definition"></a></dt>
<dd><p>Return weights for averaging the variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var_shape</strong> (<em>tuple</em>) – variable shape</p></li>
<li><p><strong>lat_c</strong> – latitude of cell centers [°]</p></li>
<li><p><strong>axis</strong> – position of the latitude axis for 2D and higher
dimensional arrays. The default is the SECOND TO LAST dimension</p></li>
</ul>
</dd>
</dl>
<p>Expected dimensions are:
[lat] <code class="docutils literal notranslate"><span class="pre">axis</span></code> not needed
[lat, lon] <code class="docutils literal notranslate"><span class="pre">axis</span> <span class="pre">=</span> <span class="pre">-2</span></code> or <code class="docutils literal notranslate"><span class="pre">axis</span> <span class="pre">=</span> <span class="pre">0</span></code>
[time, lat, lon] <code class="docutils literal notranslate"><span class="pre">axis</span> <span class="pre">=</span> <span class="pre">-2</span></code> or <code class="docutils literal notranslate"><span class="pre">axis</span> <span class="pre">=</span> <span class="pre">1</span></code>
[time, lev, lat, lon] <code class="docutils literal notranslate"><span class="pre">axis</span> <span class="pre">=</span> <span class="pre">-2</span></code> or <code class="docutils literal notranslate"><span class="pre">axis</span> <span class="pre">=</span> <span class="pre">2</span></code>
[time, time_of_day_24, lat, lon] <code class="docutils literal notranslate"><span class="pre">axis</span> <span class="pre">=</span> <span class="pre">-2</span></code> or <code class="docutils literal notranslate"><span class="pre">axis</span> <span class="pre">=</span> <span class="pre">2</span></code>
[time, time_of_day_24, lev, lat, lon] <code class="docutils literal notranslate"><span class="pre">axis</span> <span class="pre">=</span> <span class="pre">-2</span></code> or <code class="docutils literal notranslate"><span class="pre">axis</span> <span class="pre">=</span> <span class="pre">3</span></code></p>
<p>Because <code class="docutils literal notranslate"><span class="pre">dlat</span></code> is computed as <code class="docutils literal notranslate"><span class="pre">lat_c[1]-lat_c[0]</span></code>, <code class="docutils literal notranslate"><span class="pre">lat_c</span></code>
may be truncated on either end (e.g., <code class="docutils literal notranslate"><span class="pre">lat</span> <span class="pre">=</span> <span class="pre">[-20</span> <span class="pre">...,</span> <span class="pre">0...</span> <span class="pre">50]</span></code>)
but must be continuous.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">W</span></code> weights for the variable ready for standard
averaging as <code class="docutils literal notranslate"><span class="pre">np.mean(var*W)</span></code> [condensed form] or
<code class="docutils literal notranslate"><span class="pre">np.average(var,</span> <span class="pre">weights=W)</span></code> [expanded form]</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Given a variable var:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="o">=</span> <span class="p">[</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="o">...</span><span class="n">vn</span><span class="p">]</span>
</pre></div>
</div>
<p>The regular average is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">AVG</span> <span class="o">=</span> <span class="p">(</span><span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span> <span class="o">+</span> <span class="o">...</span> <span class="n">vn</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span>
</pre></div>
</div>
<p>and the weighted average is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">AVG_W</span> <span class="o">=</span> <span class="p">(</span><span class="n">v1</span><span class="o">*</span><span class="n">w1</span> <span class="o">+</span> <span class="n">v2</span><span class="o">*</span><span class="n">w2</span> <span class="o">+</span> <span class="o">...</span> <span class="n">vn</span><span class="o">*</span><span class="n">wn</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">w1</span> <span class="o">+</span> <span class="n">w2</span> <span class="o">+</span> <span class="o">...</span><span class="n">wn</span><span class="p">)</span>
</pre></div>
</div>
<p>This function returns:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">W</span> <span class="o">=</span> <span class="p">[</span><span class="n">w1</span><span class="p">,</span> <span class="n">w2</span><span class="p">,</span> <span class="o">...</span> <span class="p">,</span> <span class="n">wn</span><span class="p">]</span><span class="o">*</span><span class="n">N</span> <span class="o">/</span> <span class="p">(</span><span class="n">w1</span> <span class="o">+</span> <span class="n">w2</span> <span class="o">+</span> <span class="o">...</span><span class="n">wn</span><span class="p">)</span>
</pre></div>
</div>
<p>Therfore taking a regular average of (<code class="docutils literal notranslate"><span class="pre">var*W</span></code>) with
<code class="docutils literal notranslate"><span class="pre">np.mean(var*W)</span></code> or <code class="docutils literal notranslate"><span class="pre">np.average(var,</span> <span class="pre">weights=W)</span></code> returns
the weighted average of the variable. Use
<code class="docutils literal notranslate"><span class="pre">np.average(var,</span> <span class="pre">weights=W,</span> <span class="pre">axis</span> <span class="pre">=</span> <span class="pre">X)</span></code> to average over a
specific axis.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.areo_avg">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">areo_avg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">VAR</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">areo</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ls_target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ls_angle</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.areo_avg" title="Link to this definition"></a></dt>
<dd><p>Return a value average over a central solar longitude</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>VAR</strong> (<em>ND array</em>) – a variable with <code class="docutils literal notranslate"><span class="pre">time</span></code> in the 1st dimension</p></li>
<li><p><strong>areo</strong> (<em>1D array</em>) – solar longitude of the input variable (0-720)</p></li>
<li><p><strong>Ls_target</strong> (<em>float</em>) – central solar longitude of interest</p></li>
<li><p><strong>Ls_angle</strong> (<em>float</em>) – requested window angle centered at <code class="docutils literal notranslate"><span class="pre">Ls_target</span></code></p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>symmetric: If <code class="docutils literal notranslate"><span class="pre">True</span></code> and the requested window is out of range,</dt><dd><p><code class="docutils literal notranslate"><span class="pre">Ls_angle</span></code> is reduced. If False, the time average is performed
on the data available</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the variable averaged over solar longitudes
<code class="docutils literal notranslate"><span class="pre">Ls_target-Ls_angle/2</span></code> to <code class="docutils literal notranslate"><span class="pre">Ls_target+Ls_angle/2</span></code></p>
</dd>
</dl>
<p>EX:
<code class="docutils literal notranslate"><span class="pre">Ls_target</span> <span class="pre">=</span> <span class="pre">90.</span></code>
<code class="docutils literal notranslate"><span class="pre">Ls_angle</span> <span class="pre">=</span> <span class="pre">10.</span></code></p>
<p>Nominally, the time average is done over solar longitudes
<code class="docutils literal notranslate"><span class="pre">85</span> <span class="pre">&lt;</span> <span class="pre">Ls_target</span> <span class="pre">&lt;</span> <span class="pre">95</span></code> (10°).</p>
<p>If <code class="docutils literal notranslate"><span class="pre">symmetric</span> <span class="pre">=</span> <span class="pre">True</span></code> and the input data range is Ls = 88-100°
then <code class="docutils literal notranslate"><span class="pre">88</span> <span class="pre">&lt;</span> <span class="pre">Ls_target</span> <span class="pre">&lt;</span> <span class="pre">92</span></code> (4°, symmetric)</p>
<p>If <code class="docutils literal notranslate"><span class="pre">symmetric</span> <span class="pre">=</span> <span class="pre">False</span></code> and the input data range is Ls = 88-100°
then <code class="docutils literal notranslate"><span class="pre">88</span> <span class="pre">&lt;</span> <span class="pre">Ls_target</span> <span class="pre">&lt;</span> <span class="pre">95</span></code> (7°, assymetric)</p>
<p>..NOTE:: The routine can bin data from muliples Mars years</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.mass_stream">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">mass_stream</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v_avg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pstd'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psfc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">700</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8000.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.mass_stream" title="Link to this definition"></a></dt>
<dd><p>Compute the mass stream function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>                        P
                        ⌠
Ph i= (2 pi a) cos(lat)/g ⎮vz_tavg dp
                        ⌡
                        p_top
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v_avg</strong> (<em>ND array</em>) – zonal wind [m/s] with <code class="docutils literal notranslate"><span class="pre">lev</span></code> dimension FIRST and
<code class="docutils literal notranslate"><span class="pre">lat</span></code> dimension SECOND (e.g., <code class="docutils literal notranslate"><span class="pre">[pstd,</span> <span class="pre">lat]</span></code>,
<code class="docutils literal notranslate"><span class="pre">[pstd,</span> <span class="pre">lat,</span> <span class="pre">lon]</span></code> or <code class="docutils literal notranslate"><span class="pre">[pstd,</span> <span class="pre">lat,</span> <span class="pre">lon,</span> <span class="pre">time]</span></code>)</p></li>
<li><p><strong>lat</strong> (<em>1D array</em>) – latitudes [°]</p></li>
<li><p><strong>level</strong> (<em>1D array</em>) – interpolated layers [Pa] or [m]</p></li>
<li><p><strong>type</strong> (<em>str</em>) – interpolation type (“pstd”, “zstd” or “zagl”)</p></li>
<li><p><strong>psfc</strong> (<em>float</em>) – reference surface pressure [Pa]</p></li>
<li><p><strong>H</strong> (<em>float</em>) – reference scale height [m] when pressures are used</p></li>
<li><p><strong>factor</strong> (<em>int</em>) – normalize the mass stream function by a factor, use
<code class="docutils literal notranslate"><span class="pre">factor</span> <span class="pre">=</span> <span class="pre">1</span></code> for [kg/s]</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">MSF</span></code> the meridional mass stream function (in
<code class="docutils literal notranslate"><span class="pre">factor</span> <span class="pre">*</span> <span class="pre">[kg/s]</span></code>)</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This routine allows the time and zonal averages to be
computed before OR after the MSF calculation.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The expressions for MSF use log(pressure) Z coordinates,
which integrate better numerically.</p>
<p>With <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">p_sfc</span> <span class="pre">exp(-Z/H)</span></code> and <code class="docutils literal notranslate"><span class="pre">Z</span> <span class="pre">=</span> <span class="pre">H</span> <span class="pre">log(p_sfc/p)</span></code>
then <code class="docutils literal notranslate"><span class="pre">dp</span> <span class="pre">=</span> <span class="pre">-p_sfc/H</span> <span class="pre">exp(-Z/H)</span> <span class="pre">dZ</span></code> and we have:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>                                Z_top
                                ⌠
Phi = +(2pi a)cos(lat)psfc/(gH) ⎮v_rmv exp(-Z/H)dZ
                                ⌡
                                Z
</pre></div>
</div>
<p>With <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">p_sfc</span> <span class="pre">exp(-Z/H)</span></code></p>
<p>The integral is calculated using trapezoidal rule:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    n
    ⌠
.g. ⌡ f(z)dz = (Zn-Zn-1){f(Zn) + f(Zn-1)}/2
  n-1
</pre></div>
</div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.vw_from_MSF">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">vw_from_MSF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ztype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pstd'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psfc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">700</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8000.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.vw_from_MSF" title="Link to this definition"></a></dt>
<dd><p>Return the V and W components of the circulation from the mass
stream function.</p>
<blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">param msf<span class="colon">:</span></dt>
<dd class="field-odd"><p>the mass stream function with <code class="docutils literal notranslate"><span class="pre">lev</span></code> SECOND TO
LAST and the <code class="docutils literal notranslate"><span class="pre">lat</span></code> dimension LAST (e.g., <code class="docutils literal notranslate"><span class="pre">[lev,</span> <span class="pre">lat]</span></code>,
<code class="docutils literal notranslate"><span class="pre">[time,</span> <span class="pre">lev,</span> <span class="pre">lat]</span></code>, <code class="docutils literal notranslate"><span class="pre">[time,</span> <span class="pre">lon,</span> <span class="pre">lev,</span> <span class="pre">lat]</span></code>)</p>
</dd>
<dt class="field-even">type msf<span class="colon">:</span></dt>
<dd class="field-even"><p>ND array</p>
</dd>
<dt class="field-odd">param lat<span class="colon">:</span></dt>
<dd class="field-odd"><p>latitude [°]</p>
</dd>
<dt class="field-even">type lat<span class="colon">:</span></dt>
<dd class="field-even"><p>1D array</p>
</dd>
<dt class="field-odd">param lev<span class="colon">:</span></dt>
<dd class="field-odd"><p>level [Pa] or [m] (<code class="docutils literal notranslate"><span class="pre">pstd</span></code>, <code class="docutils literal notranslate"><span class="pre">zagl</span></code>, <code class="docutils literal notranslate"><span class="pre">zstd</span></code>)</p>
</dd>
<dt class="field-even">type lev<span class="colon">:</span></dt>
<dd class="field-even"><p>1D array</p>
</dd>
<dt class="field-odd">param ztype<span class="colon">:</span></dt>
<dd class="field-odd"><p>Use “pstd” for pressure so vertical
differentation is done in log space.</p>
</dd>
<dt class="field-even">type ztype<span class="colon">:</span></dt>
<dd class="field-even"><p>str</p>
</dd>
<dt class="field-odd">param norm<span class="colon">:</span></dt>
<dd class="field-odd"><p>if True, normalize <code class="docutils literal notranslate"><span class="pre">lat</span></code> and <code class="docutils literal notranslate"><span class="pre">lev</span></code> before
differentiating to avoid having to rescale manually the
vectors in quiver plots</p>
</dd>
<dt class="field-even">type norm<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
<dt class="field-odd">param psfc<span class="colon">:</span></dt>
<dd class="field-odd"><p>surface pressure for pseudo-height when
<code class="docutils literal notranslate"><span class="pre">ztype</span> <span class="pre">=</span> <span class="pre">&quot;pstd&quot;</span></code></p>
</dd>
<dt class="field-even">type psfc<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
<dt class="field-odd">param H<span class="colon">:</span></dt>
<dd class="field-odd"><p>scale height for pseudo-height when <code class="docutils literal notranslate"><span class="pre">ztype</span> <span class="pre">=</span> <span class="pre">&quot;pstd&quot;</span></code></p>
</dd>
<dt class="field-even">type H<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the meditional and altitude components of the mass stream
function for plotting as a quiver or streamlines.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The components are:
<code class="docutils literal notranslate"><span class="pre">[v]=</span>&#160; <span class="pre">g/(2</span> <span class="pre">pi</span> <span class="pre">cos(lat))</span> <span class="pre">dphi/dz</span></code>
<code class="docutils literal notranslate"><span class="pre">[w]=</span> <span class="pre">-g/(2</span> <span class="pre">pi</span> <span class="pre">cos(lat))</span> <span class="pre">dphi/dlat</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.alt_KM">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">alt_KM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">press</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_height_KM</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference_press</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">610.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.alt_KM" title="Link to this definition"></a></dt>
<dd><p>Gives the approximate altitude [km] for a given pressure</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>press</strong> (<em>1D array</em>) – the pressure [Pa]</p></li>
<li><p><strong>scale_height_KM</strong> (<em>float</em>) – scale height [km] (default is 8 km, an
isothermal at 155K)</p></li>
<li><p><strong>reference_press</strong> (<em>float</em>) – reference surface pressure [Pa] (default is
610 Pa)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">z_KM</span></code> the equivalent altitude for that pressure [km]</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Scale height is <code class="docutils literal notranslate"><span class="pre">H</span> <span class="pre">=</span> <span class="pre">rT/g</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.press_pa">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">press_pa</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">alt_KM</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_height_KM</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference_press</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">610.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.press_pa" title="Link to this definition"></a></dt>
<dd><p>Gives the approximate altitude [km] for a given pressure</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>alt_KM</strong> (<em>1D array</em>) – the altitude [km]</p></li>
<li><p><strong>scale_height_KM</strong> (<em>float</em>) – scale height [km] (default is 8 km, an
isothermal at 155K)</p></li>
<li><p><strong>reference_press</strong> (<em>float</em>) – reference surface pressure [Pa] (default is
610 Pa)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">press_pa</span></code> the equivalent pressure at that altitude [Pa]</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Scale height is <code class="docutils literal notranslate"><span class="pre">H</span> <span class="pre">=</span> <span class="pre">rT/g</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.shiftgrid_360_to_180">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">shiftgrid_360_to_180</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.shiftgrid_360_to_180" title="Link to this definition"></a></dt>
<dd><p>This function shifts ND data from a 0-360 to a -180/180 grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lon</strong> (<em>1D array</em>) – longitudes in the 0-360 coordinate system</p></li>
<li><p><strong>data</strong> (<em>ND array</em>) – variable with <code class="docutils literal notranslate"><span class="pre">lon</span></code> in the last dimension</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>shifted data</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">np.ma.hstack</span></code> instead of <code class="docutils literal notranslate"><span class="pre">np.hstack</span></code> to keep the
masked array properties</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.shiftgrid_180_to_360">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">shiftgrid_180_to_360</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.shiftgrid_180_to_360" title="Link to this definition"></a></dt>
<dd><p>This function shifts ND data from a -180/180 to a 0-360 grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lon</strong> (<em>1D array</em>) – longitudes in the 0-360 coordinate system</p></li>
<li><p><strong>data</strong> (<em>ND array</em>) – variable with <code class="docutils literal notranslate"><span class="pre">lon</span></code> in the last dimension</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>shifted data</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.second_hhmmss">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">second_hhmmss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seconds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lon_180</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.second_hhmmss" title="Link to this definition"></a></dt>
<dd><p>Given the time [sec], return local true solar time at a
certain longitude.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>seconds</strong> (<em>float</em>) – the time [sec]</p></li>
<li><p><strong>lon_180</strong> (<em>float</em>) – the longitude in -180/180 coordinate</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the local time [float] or a tuple (hours, minutes, seconds)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.sol_hhmmss">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">sol_hhmmss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">time_sol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lon_180</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.sol_hhmmss" title="Link to this definition"></a></dt>
<dd><p>Given the time in days, return return local true solar time at a
certain longitude.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time_sol</strong> – the time in sols</p></li>
<li><p><strong>lon_180</strong> (<em>float</em>) – the longitude in -180/180 coordinate</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the local time [float] or a tuple (hours, minutes, seconds)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.UT_LTtxt">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">UT_LTtxt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">UT_sol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lon_180</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">roundmin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.UT_LTtxt" title="Link to this definition"></a></dt>
<dd><p>Returns the time in HH:MM:SS at a certain longitude.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>time_sol</strong> (<em>float</em>) – the time in sols</p></li>
<li><p><strong>lon_180</strong> (<em>float</em>) – the center longitude in -180/180 coordinates.
Increments by 1hr every 15°</p></li>
<li><p><strong>roundmin</strong> (<em>int</em>) – round to the nearest X minute. Typical values are
<code class="docutils literal notranslate"><span class="pre">roundmin</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">15,</span> <span class="pre">60</span></code></p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="docutils literal notranslate"><span class="pre">roundmin</span></code> is requested, seconds are not shown</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.dvar_dh">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">dvar_dh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.dvar_dh" title="Link to this definition"></a></dt>
<dd><p>Differentiate an array <code class="docutils literal notranslate"><span class="pre">A[dim1,</span> <span class="pre">dim2,</span> <span class="pre">dim3...]</span></code> w.r.t <code class="docutils literal notranslate"><span class="pre">h</span></code>. The
differentiated dimension must be the first dimension.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">h</span></code> is 1D, then <code class="docutils literal notranslate"><span class="pre">h``and</span> <span class="pre">``dim1</span></code> must have the same length</p>
<dl class="simple">
<dt>If <code class="docutils literal notranslate"><span class="pre">h</span></code> is 2D, 3D or 4D, then <code class="docutils literal notranslate"><span class="pre">arr</span></code> and <code class="docutils literal notranslate"><span class="pre">h</span></code> must have the</dt><dd><p>same shape</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arr</strong> (<em>ND array</em>) – variable</p></li>
<li><p><strong>h</strong> (<em>str</em>) – the dimension (<code class="docutils literal notranslate"><span class="pre">Z</span></code>, <code class="docutils literal notranslate"><span class="pre">P</span></code>, <code class="docutils literal notranslate"><span class="pre">lat</span></code>, <code class="docutils literal notranslate"><span class="pre">lon</span></code>)</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Returns:</dt><dd><p>d_arr: the array differentiated w.r.t <code class="docutils literal notranslate"><span class="pre">h</span></code>, e.g., d(array)/dh</p>
</dd>
</dl>
<p>EX: Compute <code class="docutils literal notranslate"><span class="pre">dT/dz</span></code> where <code class="docutils literal notranslate"><span class="pre">T[time,</span> <span class="pre">lev,</span> <span class="pre">lat,</span> <span class="pre">lon]</span></code> is the
temperature and <code class="docutils literal notranslate"><span class="pre">Zkm</span></code> is the array of  level heights [km].</p>
<p>First, transpose <code class="docutils literal notranslate"><span class="pre">T</span></code> so the vertical dimension comes first:
<code class="docutils literal notranslate"><span class="pre">T[lev,</span> <span class="pre">time,</span> <span class="pre">lat,</span> <span class="pre">lon]</span></code>.</p>
<p>Then transpose back to get <code class="docutils literal notranslate"><span class="pre">dTdz[time,</span> <span class="pre">lev,</span> <span class="pre">lat,</span> <span class="pre">lon]</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dTdz</span> <span class="o">=</span> <span class="n">dvar_dh</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]),</span>
               <span class="n">Zkm</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.zonal_detrend">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">zonal_detrend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">VAR</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.zonal_detrend" title="Link to this definition"></a></dt>
<dd><p>Substract the zonal average mean value from a field.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>VAR</strong> (<em>ND array</em>) – variable with detrending dimension last</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>detrented field (same size as input)</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">RuntimeWarnings</span></code> are expected if the slice contains
only NaNs which is the case below the surface and above the
model top in the interpolated files. This routine disables such
warnings temporarily.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.get_trend_2D">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">get_trend_2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">VAR</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">LON</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">LAT</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type_trend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'wmean'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.get_trend_2D" title="Link to this definition"></a></dt>
<dd><p>Extract spatial trends from the data. The output can be directly
subtracted from the original field.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>VAR</strong> (<em>ND array</em>) – Variable for decomposition. <code class="docutils literal notranslate"><span class="pre">lat</span></code> is SECOND TO LAST
and <code class="docutils literal notranslate"><span class="pre">lon</span></code> is LAST  (e.g., <code class="docutils literal notranslate"><span class="pre">[time,</span> <span class="pre">lat,</span> <span class="pre">lon]</span></code> or
<code class="docutils literal notranslate"><span class="pre">[time,</span> <span class="pre">lev,</span> <span class="pre">lat,</span> <span class="pre">lon]</span></code>)</p></li>
<li><p><strong>LON</strong> (<em>2D array</em>) – longitude coordinates</p></li>
<li><p><strong>LAT</strong> (<em>2D array</em>) – latitude coordinates</p></li>
<li><p><strong>type_trend</strong> (<em>str</em>) – type of averaging to perform:
“mean” - use a constant average over all lat/lon
“wmean” - use a area-weighted average over all lat/lon
“zonal” - detrend over the zonal axis only
“2D” - use a 2D planar regression (not area-weighted)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the trend, same size as <code class="docutils literal notranslate"><span class="pre">VAR</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.regression_2D">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">regression_2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">VAR</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.regression_2D" title="Link to this definition"></a></dt>
<dd><p>Linear and quadratic regression on the plane.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>2D array</em>) – first coordinate</p></li>
<li><p><strong>Y</strong> (<em>2D array</em>) – second coordinate</p></li>
<li><p><strong>VAR</strong> (<em>2D array</em>) – variable of the same size as X</p></li>
<li><p><strong>order</strong> (<em>int</em>) – 1 (linear) or 2 (quadratic)</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When <code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">=</span> <span class="pre">1</span></code>, the equation is: <code class="docutils literal notranslate"><span class="pre">aX</span> <span class="pre">+</span> <span class="pre">bY</span> <span class="pre">+</span> <span class="pre">C</span> <span class="pre">=</span> <span class="pre">Z</span></code>.
When <code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">=</span> <span class="pre">2</span></code>, the equation is:
<code class="docutils literal notranslate"><span class="pre">aX^2</span> <span class="pre">+</span> <span class="pre">2bX*Y</span> <span class="pre">+</span> <span class="pre">cY^2</span> <span class="pre">+</span> <span class="pre">2dX</span> <span class="pre">+</span> <span class="pre">2eY</span> <span class="pre">+</span> <span class="pre">f</span> <span class="pre">=</span> <span class="pre">Z</span></code></p>
</div>
<p>For the linear case::, <code class="docutils literal notranslate"><span class="pre">ax</span> <span class="pre">+</span> <span class="pre">by</span> <span class="pre">+</span> <span class="pre">c</span> <span class="pre">=</span> <span class="pre">z</span></code> is re-written as
<code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">b</span></code> with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="o">|</span><span class="n">x0</span>   <span class="n">y0</span>   <span class="mi">1</span><span class="o">|</span>        <span class="o">|</span><span class="n">a</span>      <span class="o">|</span><span class="n">z0</span>
<span class="n">A</span> <span class="o">=</span> <span class="o">|</span><span class="n">x1</span>   <span class="n">y1</span>   <span class="mi">1</span><span class="o">|</span>    <span class="n">X</span> <span class="o">=</span> <span class="o">|</span><span class="n">b</span>   <span class="n">b</span><span class="o">=</span> <span class="o">|</span>
    <span class="o">|</span>      <span class="o">...</span>  <span class="o">|</span>        <span class="o">|</span><span class="n">c</span>      <span class="o">|...</span>
    <span class="o">|</span><span class="n">xn</span>   <span class="n">yn</span>   <span class="mi">1</span><span class="o">|</span>                <span class="o">|</span><span class="n">zn</span>

        <span class="p">[</span><span class="n">n</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>           <span class="p">[</span><span class="mi">3</span><span class="p">]</span>       <span class="p">[</span><span class="n">n</span><span class="p">]</span>
</pre></div>
</div>
<p>The least-squares regression provides the solution that that
minimizes <code class="docutils literal notranslate"><span class="pre">||b</span> <span class="pre">–</span> <span class="pre">A</span> <span class="pre">x||^2</span></code></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.daily_to_average">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">daily_to_average</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">varIN</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nday</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.daily_to_average" title="Link to this definition"></a></dt>
<dd><p>Bin a variable from an <code class="docutils literal notranslate"><span class="pre">atmos_daily</span></code> file format to the
<code class="docutils literal notranslate"><span class="pre">atmos_average</span></code> file format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>varIN</strong> (<em>ND array</em>) – variable with <code class="docutils literal notranslate"><span class="pre">time</span></code> dimension first (e.g.,
<code class="docutils literal notranslate"><span class="pre">ts[time,</span> <span class="pre">lat,</span> <span class="pre">lon]</span></code>)</p></li>
<li><p><strong>dt_in</strong> (<em>float</em>) – delta of time betwen timesteps in sols (e.g.,
<code class="docutils literal notranslate"><span class="pre">dt_in</span> <span class="pre">=</span> <span class="pre">time[1]</span> <span class="pre">-</span> <span class="pre">time[0]</span></code>)</p></li>
<li><p><strong>nday</strong> (<em>int</em>) – bining period in sols, default is 5 sols</p></li>
<li><p><strong>trim</strong> (<em>bool</em>) – whether to discard any leftover data at the end of file
before binning</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the variable bin over <code class="docutils literal notranslate"><span class="pre">nday</span></code></p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="docutils literal notranslate"><span class="pre">varIN[time,</span> <span class="pre">lat,</span> <span class="pre">lon]</span></code> from <code class="docutils literal notranslate"><span class="pre">atmos_daily</span></code> is
<code class="docutils literal notranslate"><span class="pre">[160,</span> <span class="pre">48,</span> <span class="pre">96]</span></code> and has 4 timesteps per day (every 6 hours),
then the resulting variable for <code class="docutils literal notranslate"><span class="pre">nday</span> <span class="pre">=</span> <span class="pre">5</span></code> is
<code class="docutils literal notranslate"><span class="pre">varOUT(160/(4*5),</span> <span class="pre">48,</span> <span class="pre">96)</span> <span class="pre">=</span> <span class="pre">varOUT(8,</span> <span class="pre">48,</span> <span class="pre">96)</span></code></p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the daily file has 668 sols, then there are
<code class="docutils literal notranslate"><span class="pre">133</span> <span class="pre">x</span> <span class="pre">5</span> <span class="pre">+</span> <span class="pre">3</span></code> sols leftover. If <code class="docutils literal notranslate"><span class="pre">trim</span> <span class="pre">=</span> <span class="pre">True</span></code>, then the
time is 133 and last 3 sols the are discarded. If
<code class="docutils literal notranslate"><span class="pre">trim</span> <span class="pre">=</span> <span class="pre">False</span></code>, the time is 134 and last bin contains only
3 sols of data.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.daily_to_diurn">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">daily_to_diurn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">varIN</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_in</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.daily_to_diurn" title="Link to this definition"></a></dt>
<dd><p>Bin a variable from an <code class="docutils literal notranslate"><span class="pre">atmos_daily</span></code> file into the
<code class="docutils literal notranslate"><span class="pre">atmos_diurn</span></code> format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>varIN</strong> (<em>ND array</em>) – variable with time dimension first (e.g.,
<code class="docutils literal notranslate"><span class="pre">[time,</span> <span class="pre">lat,</span> <span class="pre">lon]</span></code>)</p></li>
<li><p><strong>time_in</strong> (<em>ND array</em>) – time array in sols. Only the first N elements
are actually required if saving memory is important</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the variable binned in the <code class="docutils literal notranslate"><span class="pre">atmos_diurn</span></code> format
(<code class="docutils literal notranslate"><span class="pre">[time,</span> <span class="pre">time_of_day,</span> <span class="pre">lat,</span> <span class="pre">lon]</span></code>) and the time of day array
[hr]</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="docutils literal notranslate"><span class="pre">varIN[time,</span> <span class="pre">lat,</span> <span class="pre">lon]</span></code> from <code class="docutils literal notranslate"><span class="pre">atmos_daily</span></code> is
<code class="docutils literal notranslate"><span class="pre">[40,</span> <span class="pre">48,</span> <span class="pre">96]</span></code> and has 4 timestep per day (every 6 hours),
then the resulting variable is
<code class="docutils literal notranslate"><span class="pre">varOUT[10,</span> <span class="pre">4,</span> <span class="pre">48,</span> <span class="pre">96]</span> <span class="pre">=</span> <span class="pre">[time,</span> <span class="pre">time_of_day,</span> <span class="pre">lat,</span> <span class="pre">lon]</span></code> and
<code class="docutils literal notranslate"><span class="pre">tod</span> <span class="pre">=</span> <span class="pre">[0.,</span> <span class="pre">6.,</span> <span class="pre">12.,</span> <span class="pre">18.]</span></code>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Since the time dimension is first, the output variables
may be passed to the <code class="docutils literal notranslate"><span class="pre">daily_to_average()</span></code> function for
further binning.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.gauss_profile">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">gauss_profile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.gauss_profile" title="Link to this definition"></a></dt>
<dd><p>Return Gaussian line shape at x. This can be used to generate a
bell-shaped mountain.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.compute_uneven_sigma">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">compute_uneven_sigma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_levels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N_scale_heights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surf_res</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exponent</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zero_top</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.compute_uneven_sigma" title="Link to this definition"></a></dt>
<dd><p>Construct an initial array of sigma based on the number of levels
and an exponent</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>num_levels</strong> (<em>float</em>) – the number of levels</p></li>
<li><p><strong>N_scale_heights</strong> (<em>float</em>) – the number of scale heights to the top of
the model (e.g., <code class="docutils literal notranslate"><span class="pre">N_scale_heights</span></code> = 12.5 ~102 km assuming an
8 km scale height)</p></li>
<li><p><strong>surf_res</strong> (<em>float</em>) – the resolution at the surface</p></li>
<li><p><strong>exponent</strong> (<em>float</em>) – an exponent to increase the thickness of the levels</p></li>
<li><p><strong>zero_top</strong> (<em>bool</em>) – if True, force the top pressure boundary
(in N = 0) to 0 Pa</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>an array of sigma layers</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.transition">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">transition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pfull</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_press</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.transition" title="Link to this definition"></a></dt>
<dd><p>Return the transition factor to construct <code class="docutils literal notranslate"><span class="pre">ak</span></code> and <code class="docutils literal notranslate"><span class="pre">bk</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pfull</strong> (<em>1D array</em>) – the pressure [Pa]</p></li>
<li><p><strong>p_sigma</strong> (<em>float</em>) – the pressure level where the vertical grid starts
transitioning from sigma to pressure</p></li>
<li><p><strong>p_press</strong> (<em>float</em>) – the pressure level above which the vertical grid is
pure (constant) pressure</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the transition factor. = 1 for pure sigma, = 0 for pure
pressure and =0-1 for the transition</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<dl class="simple">
<dt>In the MGCM code, the full pressures are computed from:</dt><dd><p>del(phalf)</p>
</dd>
<dt>pfull = —————————–</dt><dd><p>log(phalf(k+1/2)/phalf(k-1/2))</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.swinbank">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">swinbank</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">plev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psfc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ptrans</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.swinbank" title="Link to this definition"></a></dt>
<dd><p>Compute <code class="docutils literal notranslate"><span class="pre">ak</span></code> and <code class="docutils literal notranslate"><span class="pre">bk</span></code> values with a transition based on Swinbank</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>plev</strong> (<em>1D array</em>) – the pressure levels [Pa]</p></li>
<li><p><strong>psfc</strong> (<em>1D array</em>) – the surface pressure [Pa]</p></li>
<li><p><strong>ptrans</strong> (<em>1D array</em>) – the transition pressure [Pa]</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the coefficients for the new layers</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.polar_warming">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">polar_warming</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">T</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outside_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">np.NaN</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.polar_warming" title="Link to this definition"></a></dt>
<dd><p>Return the polar warming, following McDunn et al. 2013:
Characterization of middle-atmosphere polar warming at Mars, JGR
Alex Kling</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>T</strong> (<em>ND array</em>) – temperature with the lat dimension FIRST (transpose as
needed)</p></li>
<li><p><strong>lat</strong> (<em>1D array</em>) – latitude array</p></li>
<li><p><strong>outside_range</strong> (<em>float</em>) – values to set the polar warming to when
outside pf the range. Default = NaN but 0 may be desirable.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The polar warming [K]</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">polar_warming()</span></code> concatenates the results from both
hemispheres obtained from the nested function
<code class="docutils literal notranslate"><span class="pre">PW_half_hemisphere()</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.tshift">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">tshift</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timeo</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.tshift" title="Link to this definition"></a></dt>
<dd><p>Conversion to uniform local time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>array</strong> (<em>ND array</em>) – variable to be shifted. Assume <code class="docutils literal notranslate"><span class="pre">lon</span></code> is the first
dimension and <code class="docutils literal notranslate"><span class="pre">time_of_day</span></code> is the last dimension</p></li>
<li><p><strong>lon</strong> (<em>1D array</em>) – longitude</p></li>
<li><p><strong>timeo</strong> (<em>1D array</em>) – <code class="docutils literal notranslate"><span class="pre">time_of_day</span></code> index from the input file</p></li>
<li><p><strong>timex</strong> (<em>float</em><em> (</em><em>optional</em><em>)</em>) – local time(s) [hr] to shift to (e.g., <code class="docutils literal notranslate"><span class="pre">&quot;3.</span> <span class="pre">15.&quot;</span></code>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the array shifted to uniform local time</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="docutils literal notranslate"><span class="pre">timex</span></code> is not specified, the file is interpolated
on the same <code class="docutils literal notranslate"><span class="pre">time_of_day</span></code> as the input</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.lin_interp">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">lin_interp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_ref</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y_ref</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.lin_interp" title="Link to this definition"></a></dt>
<dd><p>Simple linear interpolation with no dependance on scipy</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X_in</strong> (<em>float</em><em> or </em><em>array</em>) – input values</p>
</dd>
</dl>
<p>:param X_ref x values
:type X_ref: array
:param Y_ref y values
:type Y_ref: array</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>y value linearly interpolated at <code class="docutils literal notranslate"><span class="pre">X_in</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.add_cyclic">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">add_cyclic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lon</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.add_cyclic" title="Link to this definition"></a></dt>
<dd><p>Add a cyclic (overlapping) point to a 2D array. Useful for azimuth
and orthographic projections.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>array</em>) – variable of size <code class="docutils literal notranslate"><span class="pre">[nlat,</span> <span class="pre">nlon]</span></code></p></li>
<li><p><strong>lon</strong> (<em>array</em>) – longitudes</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a 2D array of size <code class="docutils literal notranslate"><span class="pre">[nlat,</span> <span class="pre">nlon+1]</span></code> with last column
identical to the 1st; and a 1D array of longitudes
size [nlon+1] where the last element is <code class="docutils literal notranslate"><span class="pre">lon[-1]</span> <span class="pre">+</span> <span class="pre">dlon</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.spherical_div">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">spherical_div</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">U</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lon_deg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat_deg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3400</span> <span class="pre">*</span> <span class="pre">1000.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'varying'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.spherical_div" title="Link to this definition"></a></dt>
<dd><p>Compute the divergence of the wind fields using finite difference:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">div</span> <span class="o">=</span> <span class="n">du</span><span class="o">/</span><span class="n">dx</span> <span class="o">+</span> <span class="n">dv</span><span class="o">/</span><span class="n">dy</span>
<span class="o">-&gt;</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">r</span> <span class="n">cos</span> <span class="n">lat</span><span class="p">)[</span><span class="n">d</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">/</span><span class="n">dlon</span> <span class="o">+</span> <span class="n">d</span><span class="p">(</span><span class="n">v</span> <span class="n">cos</span> <span class="n">lat</span><span class="p">)</span><span class="o">/</span><span class="n">dlat</span><span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>U</strong> (<em>array</em>) – wind field with <code class="docutils literal notranslate"><span class="pre">lat</span></code> SECOND TO LAST and <code class="docutils literal notranslate"><span class="pre">lon</span></code> as last
dimensions (e.g., <code class="docutils literal notranslate"><span class="pre">[lat,</span> <span class="pre">lon]</span></code> or <code class="docutils literal notranslate"><span class="pre">[time,</span> <span class="pre">lev,</span> <span class="pre">lat,</span> <span class="pre">lon</span></code>]
etc.)</p></li>
<li><p><strong>V</strong> (<em>array</em>) – wind field with <code class="docutils literal notranslate"><span class="pre">lat</span></code> SECOND TO LAST and <code class="docutils literal notranslate"><span class="pre">lon</span></code> as last
dimensions (e.g., <code class="docutils literal notranslate"><span class="pre">[lat,</span> <span class="pre">lon]</span></code> or <code class="docutils literal notranslate"><span class="pre">[time,</span> <span class="pre">lev,</span> <span class="pre">lat,</span> <span class="pre">lon</span></code>]
etc.)</p></li>
<li><p><strong>lon_deg</strong> (<em>1D array</em>) – longitude [°] (2D if irregularly-spaced)</p></li>
<li><p><strong>lat_deg</strong> (<em>1D array</em>) – latitude [°] (2D if irregularly-spaced)</p></li>
<li><p><strong>R</strong> (<em>float</em>) – planetary radius [m]</p></li>
<li><p><strong>spacing</strong> (<em>str</em><em> (</em><em>defaults to &quot;varying&quot;</em><em>)</em>) – when <code class="docutils literal notranslate"><span class="pre">lon</span></code> and <code class="docutils literal notranslate"><span class="pre">lat</span></code> are 1D arrays, using
spacing = “varying” differentiates latitude and longitude. When
spacing = “regular”, <code class="docutils literal notranslate"><span class="pre">dx</span> <span class="pre">=</span> <span class="pre">lon[1]-lon[0]</span></code>,
`` dy=lat[1]-lat[0]`` and the <code class="docutils literal notranslate"><span class="pre">numpy.gradient()</span></code> method are
used</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the horizonal divergence of the wind field [m-1]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.spherical_curl">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">spherical_curl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">U</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lon_deg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat_deg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3400</span> <span class="pre">*</span> <span class="pre">1000.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'varying'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.spherical_curl" title="Link to this definition"></a></dt>
<dd><p>Compute the vertical component of the relative vorticity using
finite difference:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">curl</span> <span class="o">=</span> <span class="n">dv</span><span class="o">/</span><span class="n">dx</span> <span class="o">-</span><span class="n">du</span><span class="o">/</span><span class="n">dy</span>
     <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">r</span> <span class="n">cos</span> <span class="n">lat</span><span class="p">)[</span><span class="n">d</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">/</span><span class="n">dlon</span> <span class="o">+</span> <span class="n">d</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">cos</span> <span class="n">lat</span><span class="p">)</span><span class="o">/</span><span class="n">dlat</span><span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>U</strong> (<em>array</em>) – wind field with <code class="docutils literal notranslate"><span class="pre">lat</span></code> SECOND TO LAST and <code class="docutils literal notranslate"><span class="pre">lon</span></code> as last
dimensions (e.g., <code class="docutils literal notranslate"><span class="pre">[lat,</span> <span class="pre">lon]</span></code> or <code class="docutils literal notranslate"><span class="pre">[time,</span> <span class="pre">lev,</span> <span class="pre">lat,</span> <span class="pre">lon</span></code>]
etc.)</p></li>
<li><p><strong>V</strong> (<em>array</em>) – wind field with <code class="docutils literal notranslate"><span class="pre">lat</span></code> SECOND TO LAST and <code class="docutils literal notranslate"><span class="pre">lon</span></code> as last
dimensions (e.g., <code class="docutils literal notranslate"><span class="pre">[lat,</span> <span class="pre">lon]</span></code> or <code class="docutils literal notranslate"><span class="pre">[time,</span> <span class="pre">lev,</span> <span class="pre">lat,</span> <span class="pre">lon</span></code>]
etc.)</p></li>
<li><p><strong>lon_deg</strong> (<em>1D array</em>) – longitude [°] (2D if irregularly-spaced)</p></li>
<li><p><strong>lat_deg</strong> (<em>1D array</em>) – latitude [°] (2D if irregularly-spaced)</p></li>
<li><p><strong>R</strong> (<em>float</em>) – planetary radius [m]</p></li>
<li><p><strong>spacing</strong> (<em>str</em><em> (</em><em>defaults to &quot;varying&quot;</em><em>)</em>) – when <code class="docutils literal notranslate"><span class="pre">lon</span></code> and <code class="docutils literal notranslate"><span class="pre">lat</span></code> are 1D arrays, using
spacing = “varying” differentiates latitude and longitude. When
spacing = “regular”, <code class="docutils literal notranslate"><span class="pre">dx</span> <span class="pre">=</span> <span class="pre">lon[1]-lon[0]</span></code>,
`` dy=lat[1]-lat[0]`` and the <code class="docutils literal notranslate"><span class="pre">numpy.gradient()</span></code> method are
used</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the vorticity of the wind field [m-1]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.frontogenesis">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">frontogenesis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">U</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lon_deg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat_deg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3400</span> <span class="pre">*</span> <span class="pre">1000.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'varying'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.frontogenesis" title="Link to this definition"></a></dt>
<dd><p>Compute the frontogenesis (local change in potential temperature
gradient near a front) following Richter et al. 2010: Toward a
Physically Based Gravity Wave Source Parameterization in a General
Circulation Model, JAS 67.</p>
<p>We have <code class="docutils literal notranslate"><span class="pre">Fn</span> <span class="pre">=</span> <span class="pre">1/2</span> <span class="pre">D(Del</span> <span class="pre">Theta)^2/Dt</span></code> [K/m/s]</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>U</strong> (<em>array</em>) – wind field with <code class="docutils literal notranslate"><span class="pre">lat</span></code> SECOND TO LAST and <code class="docutils literal notranslate"><span class="pre">lon</span></code> as last
dimensions (e.g., <code class="docutils literal notranslate"><span class="pre">[lat,</span> <span class="pre">lon]</span></code> or <code class="docutils literal notranslate"><span class="pre">[time,</span> <span class="pre">lev,</span> <span class="pre">lat,</span> <span class="pre">lon</span></code>]
etc.)</p></li>
<li><p><strong>V</strong> (<em>array</em>) – wind field with <code class="docutils literal notranslate"><span class="pre">lat</span></code> SECOND TO LAST and <code class="docutils literal notranslate"><span class="pre">lon</span></code> as last
dimensions (e.g., <code class="docutils literal notranslate"><span class="pre">[lat,</span> <span class="pre">lon]</span></code> or <code class="docutils literal notranslate"><span class="pre">[time,</span> <span class="pre">lev,</span> <span class="pre">lat,</span> <span class="pre">lon</span></code>]
etc.)</p></li>
<li><p><strong>theta</strong> (<em>array</em>) – potential temperature [K]</p></li>
<li><p><strong>lon_deg</strong> (<em>1D array</em>) – longitude [°] (2D if irregularly-spaced)</p></li>
<li><p><strong>lat_deg</strong> (<em>1D array</em>) – latitude [°] (2D if irregularly-spaced)</p></li>
<li><p><strong>R</strong> (<em>float</em>) – planetary radius [m]</p></li>
<li><p><strong>spacing</strong> (<em>str</em><em> (</em><em>defaults to &quot;varying&quot;</em><em>)</em>) – when <code class="docutils literal notranslate"><span class="pre">lon</span></code> and <code class="docutils literal notranslate"><span class="pre">lat</span></code> are 1D arrays, using
spacing = “varying” differentiates latitude and longitude. When
spacing = “regular”, <code class="docutils literal notranslate"><span class="pre">dx</span> <span class="pre">=</span> <span class="pre">lon[1]-lon[0]</span></code>,
`` dy=lat[1]-lat[0]`` and the <code class="docutils literal notranslate"><span class="pre">numpy.gradient()</span></code> method are
used</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the frontogenesis field [m-1]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.MGSzmax_ls_lat">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">MGSzmax_ls_lat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.MGSzmax_ls_lat" title="Link to this definition"></a></dt>
<dd><p>Return the max altitude for the dust from “MGS scenario” from
Montmessin et al. (2004), Origin and role of water ice clouds in
the Martian water cycle as inferred from a general circulation model</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ls</strong> (<em>array</em>) – solar longitude [°]</p>
</dd>
</dl>
<p>:param lat : latitude [°]
:type lat: array</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>top altitude for the dust [km]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.MGStau_ls_lat">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">MGStau_ls_lat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ls</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.MGStau_ls_lat" title="Link to this definition"></a></dt>
<dd><p>Return the max altitude for the dust from “MGS scenario” from
Montmessin et al. (2004), Origin and role of water ice clouds in
the Martian water cycle as inferred from a general circulation model</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ls</strong> (<em>array</em>) – solar longitude [°]</p>
</dd>
</dl>
<p>:param lat : latitude [°]
:type lat: array</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>top altitude for the dust [km]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.broadcast">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">broadcast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var_1D</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape_out</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.broadcast" title="Link to this definition"></a></dt>
<dd><p>Broadcast a 1D array based on a variable’s dimensions</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var_1D</strong> (<em>1D array</em>) – variable (e.g., <code class="docutils literal notranslate"><span class="pre">lat</span></code> size = 36, or <code class="docutils literal notranslate"><span class="pre">time</span></code>
size = 133)</p></li>
<li><p><strong>shape_out</strong> (<em>list</em>) – broadcasting shape (e.g.,
<code class="docutils literal notranslate"><span class="pre">temp.shape</span> <span class="pre">=</span> <span class="pre">[133,</span> <span class="pre">lev,</span> <span class="pre">36,</span> <span class="pre">lon]</span></code>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(ND array) broadcasted variables (e.g., size =
<code class="docutils literal notranslate"><span class="pre">[1,36,1,1]</span></code> for <code class="docutils literal notranslate"><span class="pre">lat</span></code> or <code class="docutils literal notranslate"><span class="pre">[133,1,1,1]</span></code> for <code class="docutils literal notranslate"><span class="pre">time</span></code>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.ref_atmosphere_Mars_PTD">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">ref_atmosphere_Mars_PTD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Zi</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.ref_atmosphere_Mars_PTD" title="Link to this definition"></a></dt>
<dd><p>Analytical atmospheric model for Martian pressure, temperature, and
density. Alex Kling, June 2021</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Zi</strong> (<em>float</em><em> or </em><em>1D array</em>) – input altitude [m] (must be &gt;= 0)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple of corresponding pressure [Pa], temperature [K],</p>
</dd>
</dl>
<p>and density [kg/m3] floats or arrays</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This model was obtained by fitting globally and annually
averaged reference temperature profiles derived from the Legacy
GCM, MCS observations, and Mars Climate Database.</p>
<p>The temperature fit was constructed using quadratic temperature
<code class="docutils literal notranslate"><span class="pre">T(z)</span> <span class="pre">=</span> <span class="pre">T0</span> <span class="pre">+</span> <span class="pre">gam(z-z0)</span> <span class="pre">+</span> <span class="pre">a*(z-z0)^2</span></code> over 4 segments (0&gt;57 km,
57&gt;110 km, 110&gt;120 km and 120&gt;300 km).</p>
<p>From the ground to 120 km, the pressure is obtained by
integrating (analytically) the hydrostatic equation:</p>
<p><code class="docutils literal notranslate"><span class="pre">dp/dz=-g.</span> <span class="pre">p/(rT)</span></code> with <code class="docutils literal notranslate"><span class="pre">T(z)</span> <span class="pre">=</span> <span class="pre">T0</span> <span class="pre">+</span> <span class="pre">gam(z-z0)</span> <span class="pre">+</span> <span class="pre">a*(z-z0)^2</span></code></p>
<p>Above ~120 km, <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">P0</span> <span class="pre">exp(-(z-z0)g/rT)</span></code> is not a good
approximation as the fluid is in molecula regime. For those
altitudes, we provide a fit in the form of
<code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">P0</span> <span class="pre">exp(-az-bz^2)</span></code> based on diurnal average of the MCD
database at lat = 0, Ls = 150.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.press_to_alt_atmosphere_Mars">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">press_to_alt_atmosphere_Mars</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Pi</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.press_to_alt_atmosphere_Mars" title="Link to this definition"></a></dt>
<dd><p>Return the altitude [m] as a function of pressure from the
analytical calculation above.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Pi</strong> (<em>float</em><em> or </em><em>1D array</em>) – input pressure [Pa] (&lt;= 610 Pa)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the corresponding altitude [m] (float or 1D array)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.azimuth2cart">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">azimuth2cart</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">LAT</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">LON</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lon0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.azimuth2cart" title="Link to this definition"></a></dt>
<dd><p>Azimuthal equidistant projection. Converts from latitude-longitude
to cartesian coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>LAT</strong> (<em>1D</em><em> or </em><em>2D array</em>) – latitudes[°] size [nlat]</p></li>
<li><p><strong>LON</strong> (<em>1D</em><em> or </em><em>2D array</em>) – longitudes [°] size [nlon]</p></li>
<li><p><strong>lat0</strong> (<em>float</em>) – latitude coordinate of the pole</p></li>
<li><p><strong>lon0</strong> (<em>float</em>) – longitude coordinate of the pole</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the cartesian coordinates for the latitudes and longitudes</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.ortho2cart">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">ortho2cart</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">LAT</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">LON</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lon0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.ortho2cart" title="Link to this definition"></a></dt>
<dd><p>Orthographic projection. Converts from latitude-longitude to
cartesian coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>LAT</strong> (<em>1D</em><em> or </em><em>2D array</em>) – latitudes[°] size [nlat]</p></li>
<li><p><strong>LON</strong> (<em>1D</em><em> or </em><em>2D array</em>) – longitudes [°] size [nlon]</p></li>
<li><p><strong>lat0</strong> (<em>float</em>) – latitude coordinate of the pole</p></li>
<li><p><strong>lon0</strong> (<em>float</em>) – longitude coordinate of the pole</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the cartesian coordinates for the latitudes and longitudes;
and a mask (NaN array) that hides the back side of the planet</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.mollweide2cart">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">mollweide2cart</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">LAT</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">LON</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.mollweide2cart" title="Link to this definition"></a></dt>
<dd><p>Mollweide projection. Converts from latitude-longitude to
cartesian coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>LAT</strong> (<em>1D</em><em> or </em><em>2D array</em>) – latitudes[°] size [nlat]</p></li>
<li><p><strong>LON</strong> (<em>1D</em><em> or </em><em>2D array</em>) – longitudes [°] size [nlon]</p></li>
<li><p><strong>lat0</strong> (<em>float</em>) – latitude coordinate of the pole</p></li>
<li><p><strong>lon0</strong> (<em>float</em>) – longitude coordinate of the pole</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the cartesian coordinates for the latitudes and longitudes</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.robin2cart">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">robin2cart</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">LAT</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">LON</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.robin2cart" title="Link to this definition"></a></dt>
<dd><p>Robinson projection. Converts from latitude-longitude to cartesian
coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>LAT</strong> (<em>1D</em><em> or </em><em>2D array</em>) – latitudes[°] size [nlat]</p></li>
<li><p><strong>LON</strong> (<em>1D</em><em> or </em><em>2D array</em>) – longitudes [°] size [nlon]</p></li>
<li><p><strong>lat0</strong> (<em>float</em>) – latitude coordinate of the pole</p></li>
<li><p><strong>lon0</strong> (<em>float</em>) – longitude coordinate of the pole</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the cartesian coordinates for the latitudes and longitudes</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.sol2ls">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">sol2ls</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">jld</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cumulative</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.sol2ls" title="Link to this definition"></a></dt>
<dd><p>Return the solar longitude (Ls) as a function of the sol number.
Sol=0 is the spring equinox.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>jld</strong> (<em>float</em><em> or </em><em>1D array</em>) – sol number after perihelion</p></li>
<li><p><strong>cumulative</strong> (<em>bool</em>) – if True, result is cumulative
(Ls=0-360, 360-720 etc..)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the corresponding solar longitude</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="amescap.FV3_utils.ls2sol">
<span class="sig-prename descclassname"><span class="pre">amescap.FV3_utils.</span></span><span class="sig-name descname"><span class="pre">ls2sol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Ls_in</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#amescap.FV3_utils.ls2sol" title="Link to this definition"></a></dt>
<dd><p>Ls to sol converter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Ls_in</strong> (<em>float</em><em> or </em><em>1D array</em>) – solar longitudes (0-360…720)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the corresponding sol number</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function simply uses a numerical solver on the
<code class="docutils literal notranslate"><span class="pre">sol2ls()</span></code> function.</p>
</div>
</dd></dl>

</section>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Alex Kling, Courtney Batterson, &amp; Victoria Hartwick (Mars Climate Modeling Center | NASA Ames Research Center).</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>